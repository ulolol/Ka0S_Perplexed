<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ka0S_Perplexed</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåÄ</text></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#18181b', // zinc-900
                            secondary: '#27272a', // zinc-800
                            text: '#f4f4f5', // zinc-100
                            muted: '#a1a1aa', // zinc-400
                            border: '#3f3f46', // zinc-700
                        },
                        light: {
                            bg: '#ffffff',
                            secondary: '#f4f4f5', // zinc-100
                            text: '#18181b', // zinc-900
                            muted: '#71717a', // zinc-500
                            border: '#e4e4e7', // zinc-200
                        },
                        accent: '#24A0ED',
                    },
                    typography: (theme) => ({
                        DEFAULT: {
                            css: {
                                color: theme('colors.gray.700'),
                                a: {
                                    color: theme('colors.blue.500'),
                                    '&:hover': {
                                        color: theme('colors.blue.700'),
                                    },
                                },
                            },
                        },
                        dark: {
                            css: {
                                color: theme('colors.gray.300'),
                                a: {
                                    color: theme('colors.blue.400'),
                                    '&:hover': {
                                        color: theme('colors.blue.600'),
                                    },
                                },
                            },
                        },
                    }),
                },
            },
        }
    </script>

    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Marked.js for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- DOMPurify -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #52525b;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #71717a;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Markdown Styles */
        .prose p {
            margin-bottom: 1em;
        }

        .prose ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        .prose ol {
            list-style-type: decimal;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        .prose h1,
        .prose h2,
        .prose h3 {
            font-weight: bold;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        .prose h1 {
            font-size: 1.5em;
        }

        .prose h2 {
            font-size: 1.25em;
        }

        .prose h3 {
            font-size: 1.1em;
        }

        .prose code {
            background-color: rgba(128, 128, 128, 0.2);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: monospace;
        }

        .prose pre {
            background-color: #27272a;
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1em;
        }

        .prose pre code {
            background-color: transparent;
            padding: 0;
        }

        .prose blockquote {
            border-left: 4px solid #3f3f46;
            padding-left: 1em;
            font-style: italic;
            margin-bottom: 1em;
        }

        /* Citation Styles */
        .citation-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.2em;
            height: 1.2em;
            border-radius: 50%;
            background-color: #3f3f46;
            color: #e4e4e7;
            font-size: 0.75em;
            margin-left: 0.2em;
            text-decoration: none;
            vertical-align: super;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .citation-link:hover {
            background-color: #24A0ED;
            color: white;
        }
    </style>
</head>

<body
    class="bg-light-bg dark:bg-dark-bg text-light-text dark:text-dark-text h-screen flex overflow-hidden font-sans selection:bg-accent selection:text-white"
    x-data="app()" x-init="initApp()">

    <!-- Sidebar -->
    <aside
        class="w-64 bg-light-secondary dark:bg-dark-secondary border-r border-light-border dark:border-dark-border flex-col hidden md:flex transition-colors duration-300">
        <div class="p-4 flex items-center justify-between">
            <div class="flex items-center gap-2 font-bold text-xl">
                <i data-lucide="layers" class="text-accent"></i>
                <span>Ka0S_Perplexed</span>
            </div>
            <button @click="startNewChat()"
                class="p-2 hover:bg-light-border dark:hover:bg-dark-border rounded-lg transition-colors"
                title="New Chat">
                <i data-lucide="plus-square"></i>
            </button>
        </div>

        <div class="flex-1 overflow-y-auto p-2 space-y-2">
            <template x-for="chat in history" :key="chat.id">
                <div class="relative group">
                    <div @click="loadChat(chat.id)"
                        class="p-3 rounded-lg cursor-pointer hover:bg-light-border dark:hover:bg-dark-border transition-colors truncate pr-8"
                        :class="{'bg-light-border dark:bg-dark-border': currentChatId === chat.id}">
                        <span x-text="chat.title || 'New Chat'" class="text-sm font-medium"></span>
                    </div>
                    <button @click.stop="deleteChat(chat.id)"
                        class="absolute right-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 p-1 hover:text-red-500 transition-opacity z-10"
                        title="Delete chat">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </div>
            </template>
        </div>

        <div class="p-4 border-t border-light-border dark:border-dark-border">
            <button @click="showSettings = true"
                class="flex items-center gap-2 w-full p-2 hover:bg-light-border dark:hover:bg-dark-border rounded-lg transition-colors text-sm font-medium">
                <i data-lucide="settings" class="w-4 h-4"></i>
                Settings
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col h-full relative">
        <!-- Mobile Header -->
        <header
            class="md:hidden flex items-center justify-between p-4 border-b border-light-border dark:border-dark-border bg-light-bg dark:bg-dark-bg z-10">
            <div class="flex items-center gap-2 font-bold">
                <i data-lucide="layers" class="text-accent"></i>
                <span>Ka0S_Perplexed</span>
            </div>
            <button @click="mobileMenuOpen = !mobileMenuOpen" class="p-2">
                <i data-lucide="menu"></i>
            </button>
        </header>

        <!-- Mobile Menu -->
        <div x-show="mobileMenuOpen" class="absolute inset-0 bg-black/50 z-40 md:hidden" @click="mobileMenuOpen = false"
            x-transition.opacity>
        </div>
        <div x-show="mobileMenuOpen"
            class="absolute inset-y-0 left-0 w-64 bg-light-secondary dark:bg-dark-secondary z-50 transform transition-transform md:hidden flex flex-col"
            x-transition:enter="transition ease-out duration-200" x-transition:enter-start="-translate-x-full"
            x-transition:enter-end="translate-x-0" x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="translate-x-0" x-transition:leave-end="-translate-x-full">
            <!-- Mobile Sidebar Content (Clone of Desktop) -->
            <div class="p-4 flex items-center justify-between border-b border-light-border dark:border-dark-border">
                <span class="font-bold">Menu</span>
                <button @click="mobileMenuOpen = false"><i data-lucide="x"></i></button>
            </div>
            <div class="p-4">
                <button @click="startNewChat(); mobileMenuOpen = false"
                    class="w-full flex items-center gap-2 p-3 bg-accent text-white rounded-lg mb-4">
                    <i data-lucide="plus"></i> New Chat
                </button>
                <div class="space-y-2 overflow-y-auto max-h-[60vh]">
                    <template x-for="chat in history" :key="chat.id">
                        <div @click="loadChat(chat.id); mobileMenuOpen = false"
                            class="p-3 rounded-lg cursor-pointer hover:bg-light-border dark:hover:bg-dark-border truncate text-sm"
                            :class="{'bg-light-border dark:bg-dark-border': currentChatId === chat.id}">
                            <span x-text="chat.title || 'New Chat'"></span>
                        </div>
                    </template>
                </div>
                <div class="p-4 border-t border-light-border dark:border-dark-border">
                    <button @click="showSettings = true; mobileMenuOpen = false"
                        class="flex items-center gap-2 w-full p-2 hover:bg-light-border dark:hover:bg-dark-border rounded-lg transition-colors text-sm font-medium">
                        <i data-lucide="settings" class="w-4 h-4"></i>
                        Settings
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="flex-1 overflow-y-auto p-4 md:p-8 scroll-smooth" id="chat-container">
            <div class="max-w-3xl mx-auto space-y-8 pb-32">

                <!-- Welcome Screen -->
                <div x-show="messages.length === 0"
                    class="flex flex-col items-center justify-center h-[60vh] text-center space-y-6 animate-fade-in">
                    <div class="w-16 h-16 bg-accent/10 rounded-2xl flex items-center justify-center mb-4">
                        <i data-lucide="layers" class="w-8 h-8 text-accent"></i>
                    </div>
                    <h1 class="text-3xl font-bold">Where knowledge begins</h1>
                    <p class="text-light-muted dark:text-dark-muted max-w-md">
                        Ask anything. Ka0S_Perplexed searches the web and uses Gemini to give you a comprehensive answer
                        with citations.
                    </p>
                </div>

                <!-- Messages -->
                <template x-for="(msg, index) in messages" :key="index">
                    <div class="animate-fade-in space-y-4">
                        <!-- User Message -->
                        <div x-show="msg.role === 'user'" class="flex flex-col space-y-2">
                            <h2 class="text-2xl font-medium" x-text="msg.content"></h2>
                        </div>

                        <!-- Assistant Message -->
                        <div x-show="msg.role === 'assistant'" class="flex flex-col space-y-6">

                            <!-- Sources Grid -->
                            <div x-show="msg.sources && msg.sources.length > 0" class="space-y-2">
                                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                    <template x-for="(source, idx) in (msg.sources || []).slice(0, 7)" :key="idx">
                                        <a :href="source.url" target="_blank"
                                            class="block p-3 bg-light-secondary dark:bg-dark-secondary rounded-lg hover:bg-light-border dark:hover:bg-dark-border transition-colors text-xs border border-light-border dark:border-dark-border truncate group">
                                            <div class="font-medium mb-1 truncate" x-text="source.title"></div>
                                            <div class="flex items-center gap-1 text-light-muted dark:text-dark-muted">
                                                <div class="w-4 h-4 rounded-full bg-light-border dark:bg-dark-border flex items-center justify-center text-[10px]"
                                                    x-text="idx + 1"></div>
                                                <span class="truncate" x-text="new URL(source.url).hostname"></span>
                                            </div>
                                        </a>
                                    </template>
                                </div>
                                <!-- Search Deeper Button -->
                                <button @click="performDeepSearch()"
                                    x-show="!msg.deepSearchPerformed && !isLoading && msg.role === 'assistant'"
                                    class="text-xs px-3 py-1.5 bg-accent/10 text-accent hover:bg-accent/20 rounded-lg transition-colors border border-accent/30">
                                    üîç Search Deeper
                                </button>
                            </div>

                            <!-- Answer Content -->
                            <div class="flex gap-4">
                                <div class="flex-shrink-0 mt-1">
                                    <i data-lucide="sparkles" class="w-5 h-5 text-accent"></i>
                                </div>
                                <div class="prose dark:prose-invert max-w-none w-full"
                                    x-html="renderMarkdown(msg.content)"></div>
                            </div>

                            <!-- Loading Indicator -->
                            <div x-show="msg.loading"
                                class="flex items-center gap-2 text-light-muted dark:text-dark-muted ml-9">
                                <i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>
                                <span class="text-sm" x-text="searchStatus || 'Thinking...'"></span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Input Area -->
        <div
            class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-light-bg dark:from-dark-bg via-light-bg dark:via-dark-bg to-transparent pt-10 pb-6 px-4 z-20">
            <div class="max-w-3xl mx-auto">
                <div
                    class="bg-light-secondary dark:bg-dark-secondary border border-light-border dark:border-dark-border rounded-2xl shadow-lg p-2 focus-within:ring-2 focus-within:ring-accent/50 transition-all">
                    <textarea x-model="input" @keydown.enter.prevent="if(!$event.shiftKey) sendMessage()"
                        placeholder="Ask anything..."
                        class="w-full bg-transparent border-none focus:ring-0 resize-none max-h-48 min-h-[50px] p-2 text-base"
                        rows="1" x-ref="inputArea"
                        @input="$el.style.height = 'auto'; $el.style.height = $el.scrollHeight + 'px'"></textarea>

                    <!-- Attached Files Preview -->
                    <div x-show="filePreviews.length" class="mt-2 px-1 space-y-1 max-h-24 overflow-y-auto">
                        <template x-for="preview in filePreviews" :key="preview.id">
                            <div
                                class="flex items-center gap-2 p-2 bg-light-bg dark:bg-dark-bg border border-light-border dark:border-dark-border rounded-lg">
                                <template x-if="preview.type?.startsWith('image/')">
                                    <img :src="'data:' + preview.type + ';base64,' + preview.data"
                                        class="w-8 h-8 object-cover rounded" :alt="preview.name">
                                </template>
                                <template x-else>
                                    <div
                                        class="w-8 h-8 bg-light-border dark:bg-dark-border rounded flex items-center justify-center">
                                        <i data-lucide="file-text"
                                            class="w-4 h-4 text-light-muted dark:text-dark-muted"></i>
                                    </div>
                                </template>
                                <span class="text-xs flex-1 min-w-0 truncate font-medium" x-text="preview.name"></span>
                                <span class="text-xs text-light-muted dark:text-dark-muted"
                                    x-text="(preview.size / 1024).toFixed(1) + ' KB'"></span>
                                <button @click="removeFile(preview.id)"
                                    class="ml-1 p-1 hover:bg-light-border dark:hover:bg-dark-border rounded text-light-muted dark:text-dark-muted hover:text-red-500">
                                    <i data-lucide="x" class="w-3 h-3"></i>
                                </button>
                            </div>
                        </template>
                    </div>

                    <div class="flex items-center justify-between px-2 pb-1 mt-2">
                        <div class="flex items-center gap-2">
                            <div class="relative" x-data="{ open: false }">
                                <button @click="open = !open"
                                    class="flex items-center gap-1 text-xs font-medium bg-light-bg dark:bg-dark-bg px-2 py-1 rounded-md border border-light-border dark:border-dark-border hover:bg-light-border dark:hover:bg-dark-border transition-colors">
                                    <span x-text="focusMode"></span>
                                    <i data-lucide="chevron-down" class="w-3 h-3"></i>
                                </button>
                                <div x-show="open" @click.outside="open = false"
                                    class="absolute bottom-full left-0 mb-2 w-48 bg-light-secondary dark:bg-dark-secondary border border-light-border dark:border-dark-border rounded-lg shadow-xl overflow-hidden z-50">
                                    <template x-for="mode in focusModes" :key="mode">
                                        <button @click="focusMode = mode; open = false"
                                            class="w-full text-left px-4 py-2 text-sm hover:bg-light-border dark:hover:bg-dark-border transition-colors"
                                            x-text="mode"></button>
                                    </template>
                                </div>
                            </div>
                            <!-- File Upload -->
                            <button type="button" @click="$refs.fileInput?.click()"
                                class="p-1.5 text-light-muted dark:text-dark-muted hover:bg-light-border dark:hover:bg-dark-border rounded transition-colors flex items-center gap-1"
                                :title="selectedFiles.length ? (selectedFiles.length + ' file' + (selectedFiles.length > 1 ? 's' : '') + ' selected') : 'Attach files/images'">
                                <i data-lucide="paperclip" class="w-4 h-4"></i>
                                <span x-show="selectedFiles.length"
                                    class="text-xs bg-accent text-white px-1.5 py-0.5 rounded-full"
                                    x-text="selectedFiles.length"></span>
                            </button>
                            <input x-ref="fileInput" type="file" multiple
                                accept="image/*,application/pdf,text/plain,.txt,.md,application/json,video/*"
                                @change="handleFiles($event)" class="hidden">
                        </div>
                        <button @click="sendMessage()" :disabled="!input.trim() || isLoading"
                            class="p-2 bg-accent text-white rounded-full hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                            <i data-lucide="arrow-up" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
                <div class="text-center mt-2 text-xs text-light-muted dark:text-dark-muted">
                    Powered by Tavily & Gemini ‚Ä¢ Local Storage Only
                </div>
            </div>
        </div>
    </main>

    <!-- Settings Modal -->
    <div x-show="showSettings" class="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4"
        x-transition.opacity>
        <div class="bg-light-bg dark:bg-dark-bg w-full max-w-md rounded-xl shadow-2xl border border-light-border dark:border-dark-border overflow-hidden"
            @click.outside="showSettings = false">
            <div class="p-4 border-b border-light-border dark:border-dark-border flex items-center justify-between">
                <h2 class="font-bold text-lg">Settings</h2>
                <button @click="showSettings = false"><i data-lucide="x"></i></button>
            </div>
            <div class="p-6 space-y-6">
                <!-- Theme Toggle -->
                <div class="flex items-center justify-between">
                    <span class="font-medium">Dark Mode</span>
                    <button @click="toggleTheme()"
                        class="w-12 h-6 rounded-full bg-light-border dark:bg-dark-border relative transition-colors">
                        <div class="w-4 h-4 bg-white rounded-full absolute top-1 transition-transform duration-200"
                            :class="isDark ? 'left-7' : 'left-1'"></div>
                    </button>
                </div>

                <!-- API Keys -->
                <div class="space-y-4">
                    <h3 class="font-medium text-sm text-light-muted dark:text-dark-muted uppercase tracking-wider">API
                        Keys</h3>

                    <div class="space-y-2">
                        <label class="text-sm font-medium">Tavily API Key</label>
                        <input type="password" x-model="apiKeys.tavily"
                            class="w-full bg-light-secondary dark:bg-dark-secondary border border-light-border dark:border-dark-border rounded-lg p-2 text-sm focus:ring-2 focus:ring-accent focus:border-transparent outline-none"
                            placeholder="tvly-...">
                    </div>

                    <div class="space-y-2">
                        <label class="text-sm font-medium">Gemini API Key</label>
                        <input type="password" x-model="apiKeys.gemini"
                            class="w-full bg-light-secondary dark:bg-dark-secondary border border-light-border dark:border-dark-border rounded-lg p-2 text-sm focus:ring-2 focus:ring-accent focus:border-transparent outline-none"
                            placeholder="AIza...">
                    </div>

                    <div class="pt-2">
                        <label class="text-xs text-accent hover:underline cursor-pointer">
                            Load from api-keys-example.json
                            <input type="file" accept=".json" @change="loadKeysFromFile($event)" class="hidden">
                        </label>
                    </div>
                </div>
            </div>
            <div
                class="p-4 border-t border-light-border dark:border-dark-border bg-light-secondary dark:bg-dark-secondary flex justify-end">
                <button @click="saveSettings()"
                    class="bg-accent text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors font-medium">Save
                    & Close</button>
            </div>
        </div>
    </div>

    <script>
        function app() {
            return {
                // State
                history: [],
                messages: [],
                currentChatId: null,
                input: '',
                isLoading: false,
                isDark: true,
                showSettings: false,
                mobileMenuOpen: false,
                focusMode: 'All',
                focusModes: ['All', 'Academic', 'YouTube', 'Reddit', 'Writing Assistant', 'Wolfram Alpha'],
                selectedFiles: [],
                filePreviews: [],
                apiKeys: {
                    tavily: '',
                    gemini: ''
                },
                searchDeeper: false,
                searchStatus: '',

                // Initialization
                initApp() {
                    // Load Theme
                    const savedTheme = localStorage.getItem('perplexica.theme');
                    this.isDark = savedTheme ? savedTheme === 'dark' : true;
                    this.applyTheme();

                    // Load Keys
                    const savedKeys = localStorage.getItem('perplexica.keys');
                    if (savedKeys) {
                        this.apiKeys = JSON.parse(savedKeys);
                    }
                    // Auto-load from api-keys-example.json (only if not opened via file://)
                    if (!location.protocol.startsWith('file')) {
                        fetch('./api-keys-example.json')
                            .then(r => r.ok ? r.json() : null)
                            .then(data => {
                                if (data) {
                                    Object.assign(this.apiKeys, data);
                                    localStorage.setItem('perplexica.keys', JSON.stringify(this.apiKeys));
                                }
                            })
                            .catch(e => {
                                // Silently ignore errors (file may not exist or network issues)
                            });
                    }

                    // Load History
                    const savedHistory = localStorage.getItem('perplexica.history');
                    if (savedHistory) {
                        this.history = JSON.parse(savedHistory);
                    }

                    // Initialize Icons
                    this.$nextTick(() => {
                        lucide.createIcons();
                    });

                    // Start new chat if empty
                    if (this.history.length === 0) {
                        this.startNewChat();
                    } else {
                        // Load most recent
                        this.loadChat(this.history[0].id);
                    }
                },

                // Theme Logic
                toggleTheme() {
                    this.isDark = !this.isDark;
                    this.applyTheme();
                    localStorage.setItem('perplexica.theme', this.isDark ? 'dark' : 'light');
                },
                applyTheme() {
                    if (this.isDark) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                },

                // Settings Logic
                saveSettings() {
                    localStorage.setItem('perplexica.keys', JSON.stringify(this.apiKeys));
                    this.showSettings = false;
                },
                async loadKeysFromFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        if (data.tavily || data.gemini) {
                            this.apiKeys = { ...this.apiKeys, ...data };
                            alert('Keys loaded! Click Save to persist.');
                        } else {
                            throw new Error('Invalid JSON format');
                        }
                    } catch (e) {
                        alert('Error loading file: ' + e.message);
                    }
                    // Reset input
                    event.target.value = '';
                },

                // Chat Management
                startNewChat() {
                    const newChat = {
                        id: Date.now().toString(),
                        title: 'New Chat',
                        messages: [],
                        timestamp: Date.now()
                    };
                    this.history.unshift(newChat);
                    this.currentChatId = newChat.id;
                    this.messages = [];
                    this.saveHistory();
                },
                loadChat(id) {
                    const chat = this.history.find(c => c.id === id);
                    if (chat) {
                        this.currentChatId = id;
                        this.messages = chat.messages.map(m => ({
                            ...m,
                            sources: m.sources || []
                        }));
                        // Scroll to bottom
                        this.$nextTick(() => {
                            const container = document.getElementById('chat-container');
                            container.scrollTop = container.scrollHeight;
                        });
                    }
                },
                deleteChat(id) {
                    this.history = this.history.filter(c => c.id !== id);
                    if (this.currentChatId === id) {
                        if (this.history.length > 0) {
                            this.loadChat(this.history[0].id);
                        } else {
                            this.startNewChat();
                        }
                    }
                    this.saveHistory();
                },
                saveHistory() {
                    // Update current chat messages
                    const chatIndex = this.history.findIndex(c => c.id === this.currentChatId);
                    if (chatIndex !== -1) {
                        this.history[chatIndex].messages = this.messages;
                        // Generate title if new
                        if (this.messages.length > 0 && this.history[chatIndex].title === 'New Chat') {
                            this.history[chatIndex].title = this.messages[0].content.slice(0, 30) + '...';
                        }
                    }
                    localStorage.setItem('perplexica.history', JSON.stringify(this.history));
                },

                // File handling methods
                async handleFiles(event) {
                    const files = Array.from(event.target.files);
                    const newFiles = [];
                    const newPreviews = [];
                    for (let i = 0; i < files.length && newFiles.length < 5; i++) {
                        const file = files[i];
                        if (file.size > 8 * 1024 * 1024) continue; // 8MB limit
                        let processed = null;
                        if (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('video/')) {
                            try {
                                const base64 = await this.fileToBase64(file);
                                processed = {
                                    id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    name: file.name,
                                    type: file.type,
                                    data: base64,
                                    content: null,
                                    size: file.size
                                };
                            } catch (e) {
                                console.warn('Failed to read file:', file.name, e);
                            }
                        } else {
                            try {
                                const content = await file.text();
                                processed = {
                                    id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    name: file.name,
                                    type: file.type,
                                    data: null,
                                    content: content.slice(0, 20000), // 20k chars max
                                    size: file.size
                                };
                            } catch (e) {
                                console.warn('Failed to read text file:', file.name, e);
                            }
                        }
                        if (processed) {
                            newFiles.push(processed);
                            newPreviews.push({ ...processed, type: processed.type || 'text' });
                        }
                    }
                    this.selectedFiles = newFiles;
                    this.filePreviews = newPreviews;
                    event.target.value = '';
                },
                fileToBase64(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result.split(',')[1]);
                        reader.onerror = () => reject(new Error('Failed to read file'));
                        reader.readAsDataURL(file);
                    });
                },
                removeFile(id) {
                    this.selectedFiles = this.selectedFiles.filter(f => f.id !== id);
                    this.filePreviews = this.filePreviews.filter(p => p.id !== id);
                },

                // Messaging Logic
                async sendMessage() {
                    if (!this.input.trim() || this.isLoading) return;

                    if (!this.apiKeys.gemini) {
                        alert('Please set your Gemini API Key in Settings.');
                        this.showSettings = true;
                        return;
                    }

                    const userQuery = this.input.trim();
                    this.input = '';
                    this.$refs.inputArea.style.height = 'auto';

                    // Add User Message
                    this.messages.push({
                        role: 'user',
                        content: userQuery
                    });

                    // Add Placeholder Assistant Message
                    const assistantMsgIndex = this.messages.push({
                        role: 'assistant',
                        content: '',
                        sources: [],
                        loading: true
                    }) - 1;

                    this.isLoading = true;
                    this.$nextTick(() => {
                        const container = document.getElementById('chat-container');
                        container.scrollTop = container.scrollHeight;
                    });

                    try {
                        let sources = [];
                        let prompt = '';

                        // Build conversation history (excluding current user message which hasn't been added yet)
                        let conversationHistory = '';
                        if (this.messages.length > 1) {
                            // Include all messages except the last one (current user message)
                            for (let i = 0; i < this.messages.length - 1; i++) {
                                const msg = this.messages[i];
                                if (msg.role === 'user') {
                                    conversationHistory += `\nUser: ${msg.content}\n`;
                                } else if (msg.role === 'assistant') {
                                    // Truncate long responses for context
                                    const content = msg.content.slice(0, 500) + (msg.content.length > 500 ? '...' : '');
                                    conversationHistory += `Assistant: ${content}\n`;
                                }
                            }
                        }

                        // 1. Content Analysis (if files attached)
                        let contentAnalysis = null;
                        if (this.selectedFiles.length > 0) {
                            contentAnalysis = await this.analyzeAttachmentsAndGenerateQueries(this.selectedFiles, userQuery);
                        }

                        // Determine search queries based on analysis
                        let searchQueriesToUse = [userQuery];
                        if (contentAnalysis && contentAnalysis.searchQueries && contentAnalysis.searchQueries.length > 0) {
                            searchQueriesToUse = contentAnalysis.searchQueries;
                        }

                        // 2. Search (if not Writing Assistant)
                        if (this.focusMode !== 'Writing Assistant' && this.apiKeys.tavily) {
                            try {

                                // Initial search with first query
                                this.searchStatus = 'Searching (1/2)...';
                                const searchResults = await this.searchTavily(searchQueriesToUse[0]);
                                if (searchResults && searchResults.results && Array.isArray(searchResults.results)) {
                                    sources = searchResults.results.map(r => ({
                                        title: r.title || 'Untitled',
                                        url: r.url || '',
                                        content: r.content || ''
                                    }));
                                } else {
                                    throw new Error('Unexpected search results format');
                                }

                                // Auto-refinement: Check if results are sufficient
                                if (sources.length > 0) {
                                    this.searchStatus = 'Evaluating search quality...';
                                    const quality = await this.checkSearchQuality(searchQueriesToUse[0], sources);

                                    if (!quality.isSufficient) {
                                        // Use generated queries or generate new ones
                                        let queryForRefinement;
                                        if (contentAnalysis && contentAnalysis.searchQueries && contentAnalysis.searchQueries.length > 1) {
                                            queryForRefinement = contentAnalysis.searchQueries[1];
                                        } else {
                                            this.searchStatus = 'Refining search...';
                                            const improvedQueries = await this.generateSearchQueries(searchQueriesToUse[0], sources, 1);
                                            queryForRefinement = improvedQueries && improvedQueries.length > 0 ? improvedQueries[0] : null;
                                        }

                                        if (queryForRefinement) {
                                            // Perform second search with improved query
                                            this.searchStatus = 'Searching (2/2)...';
                                            const refinedResults = await this.searchTavily(queryForRefinement);

                                            if (refinedResults && refinedResults.results) {
                                                const refinedSources = refinedResults.results.map(r => ({
                                                    title: r.title || 'Untitled',
                                                    url: r.url || '',
                                                    content: r.content || ''
                                                }));
                                                // Combine and deduplicate
                                                sources = this.deduplicateSources([...sources, ...refinedSources]);
                                            }
                                        }
                                    }
                                }

                                this.searchStatus = '';
                                // Update UI with sources
                                this.messages[assistantMsgIndex].sources = sources;
                            } catch (searchError) {
                                console.warn('Tavily search failed, continuing without sources:', searchError);
                                this.messages[assistantMsgIndex].sources = [];
                                this.searchStatus = '';
                            }

                            // Construct Prompt with context
                            const contextStr = sources.map((s, i) => `[${i + 1}] Title: ${s.title}\nURL: ${s.url}\nContent: ${s.content.slice(0, 2000)}`).join('\n\n');

                            let analysisContextStr = '';
                            if (contentAnalysis) {
                                console.log('Using content analysis for answer:', contentAnalysis);
                                analysisContextStr = `\nFile Analysis:\n- Description/Summary: ${contentAnalysis.description}\n- Main topic: ${contentAnalysis.mainTopic}`;
                            } else if (this.selectedFiles.length > 0) {
                                console.warn('Files attached but analysis failed, continuing without it');
                            }

                            console.log('Search queries used:', searchQueriesToUse);
                            console.log('Number of sources:', sources.length);

                            prompt = `You are Ka0S_Perplexed, an AI search engine. Answer queries based on ONLY the provided web context and file analysis.${conversationHistory ? '\n\nConversation History:' + conversationHistory : ''}${analysisContextStr}

Current Query: ${userQuery}

Web Context (from web search):
${contextStr || 'No web context available'}

Instructions:
- PRIORITIZE the web context provided - this is current information from the web.
- Combine file analysis with web context to provide a comprehensive answer.
- ALWAYS cite sources using [1], [2] notation for any information from web context.
- Reference previous conversation if relevant.
- Use Markdown for formatting.
- Do NOT list or repeat source information - just cite with numbers.
- Only use general knowledge if explicitly stated in the query (e.g., "what do you know about...").
- If web context is insufficient, state this clearly.
- Provide detailed, in-depth responses without artificial length limits.
`;
                        } else {
                            // Direct Chat Prompt (with analysis if available)
                            let analysisContextStr = '';
                            if (contentAnalysis) {
                                analysisContextStr = `\nFile Analysis:\n- Description/Summary: ${contentAnalysis.description}\n- Main topic: ${contentAnalysis.mainTopic}`;
                            }

                            prompt = `You are Ka0S_Perplexed, a helpful AI assistant.${conversationHistory ? '\n\nConversation History:' + conversationHistory : ''}${analysisContextStr}

Current Query: ${userQuery}

Instructions:
- Answer the user's query helpfully.
- Reference previous conversation if relevant to provide continuity.
- Use Markdown for formatting.
`;

                        }

                        // Process attached files
                        let parts = [];
                        if (this.selectedFiles.length > 0) {
                            let fileSummary = '\n\n**Attached files:**\n';
                            for (let file of this.selectedFiles) {
                                if (file.content) {
                                    // Append text content to prompt
                                    prompt += `\n\n--- Content of ${file.name} (text file) ---\n${file.content.slice(0, 15000)}`;
                                    fileSummary += `- ${file.name} (text, ${Math.round(file.size / 1024)}KB)\n`;
                                } else if (file.data) {
                                    // Add as inline data for vision/multimodal
                                    parts.push({
                                        inline_data: {
                                            mime_type: file.type,
                                            data: file.data
                                        }
                                    });
                                    fileSummary += `- ${file.name} (image/file, ${Math.round(file.size / 1024)}KB)\n`;
                                }
                            }
                            prompt = `Analyze any attached files as needed, then answer the query.${fileSummary}\n\n${prompt}`;
                        }

                        // Add the prompt as the first part
                        parts.unshift({ text: prompt });

                        // 2. Stream Gemini Response
                        const initialLength = this.messages[assistantMsgIndex].content.length;
                        await this.streamGemini(parts, (chunk) => {
                            this.messages[assistantMsgIndex].content += chunk;
                            // Scroll to bottom
                            const container = document.getElementById('chat-container');
                            container.scrollTop = container.scrollHeight;
                        });

                        // Validate we received content
                        if (this.messages[assistantMsgIndex].content.length === initialLength) {
                            throw new Error('No response received from Gemini API. Check your API key and try again.');
                        }

                    } catch (error) {
                        console.error('Error in sendMessage:', error);
                        this.messages[assistantMsgIndex].content += `\n\n**Error:** ${error.message}`;
                    } finally {
                        this.messages[assistantMsgIndex].loading = false;
                        this.isLoading = false;
                        // Clear attached files after send
                        this.selectedFiles = [];
                        this.filePreviews = [];
                        this.saveHistory();
                    }
                },

                // Helper: Extract valid JSON from text response
                extractJSON(text) {
                    if (!text) return null;

                    // Remove markdown code blocks
                    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                    // Find the first { and count braces to find matching }
                    let startIdx = text.indexOf('{');
                    if (startIdx === -1) return null;

                    let braceCount = 0;
                    for (let i = startIdx; i < text.length; i++) {
                        if (text[i] === '{') braceCount++;
                        else if (text[i] === '}') {
                            braceCount--;
                            if (braceCount === 0) {
                                return text.substring(startIdx, i + 1);
                            }
                        }
                    }

                    return null;
                },

                // File Analysis & Context Generation
                async analyzeAttachmentsAndGenerateQueries(files, userQuery) {
                    // Analyze images and text files to generate optimized search queries
                    if (!files || files.length === 0) return null;

                    try {
                        this.searchStatus = 'Analyzing attached files...';
                        console.log('Starting analysis for', files.length, 'files');

                        // Build parts array
                        const parts = [];

                        // Add files (images, PDFs, videos)
                        for (let file of files) {
                            if (file.data && file.type && (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('video/'))) {
                                parts.push({
                                    inline_data: {
                                        mime_type: file.type,
                                        data: file.data
                                    }
                                });
                            } else if (file.content) {
                                // Add text content
                                parts.push({
                                    text: `Content of file "${file.name}":\n${file.content.slice(0, 20000)}`
                                });
                            }
                        }

                        // Add analysis prompt
                        parts.push({
                            text: `Analyze the attached file(s) (images and/or text) to generate web search queries.
User query: "${userQuery}"

Respond with ONLY valid JSON (no markdown):
{
  "description": "2-3 sentence description of what you see or read in the files",
  "mainTopic": "the primary subject in one phrase",
  "searchQueries": ["specific search query 1", "specific search query 2", "specific search query 3"]
}`
                        });

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts }],
                                generationConfig: {
                                    temperature: 0.3,
                                    maxOutputTokens: 8192,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) {
                            console.warn('File analysis API failed:', response.status);
                            return null;
                        }

                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text;

                        if (!text) {
                            console.warn('No text in file analysis response', data);
                            return null;
                        }

                        console.log('File analysis raw response:', text);

                        // Extract valid JSON from response
                        const jsonStr = this.extractJSON(text);
                        if (!jsonStr) {
                            console.warn('Could not extract JSON from file analysis response:', text);
                            return null;
                        }

                        console.log('Extracted JSON:', jsonStr);
                        const result = JSON.parse(jsonStr);
                        console.log('File analysis result:', result);
                        this.searchStatus = '';
                        return result;
                    } catch (e) {
                        console.error('File analysis failed:', e);
                        this.searchStatus = '';
                        return null;
                    }
                },

                // Search Refinement & Deep Search
                async checkSearchQuality(query, results) {
                    // Ask Gemini if search results are sufficient
                    try {
                        const prompt = `Query: "${query}"

Search Results (${results.length} found):
${results.map((r, i) => `${i + 1}. ${r.title}`).join('\n')}

Are these results specific and detailed enough to comprehensively answer the query? Be strict - require evidence that results cover the topic. Respond ONLY with JSON (no markdown, no code blocks):
{"isSufficient": false, "reason": "reason why"}`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.2,
                                    maxOutputTokens: 8192,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) return { isSufficient: false };
                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

                        if (!text) {
                            console.warn('Quality check response empty. Full data:', JSON.stringify(data, null, 2));
                        } else {
                            console.log('Quality check raw response:', text);
                        }

                        // Extract valid JSON from response
                        const jsonStr = this.extractJSON(text);
                        if (!jsonStr) {
                            console.warn('Could not extract JSON from quality check response:', text);
                            return { isSufficient: false };
                        }

                        console.log('Extracted quality check JSON:', jsonStr);
                        const result = JSON.parse(jsonStr);
                        console.debug('Quality check result:', result);
                        return result;
                    } catch (e) {
                        console.error('Quality check failed, assuming insufficient:', e);
                        return { isSufficient: false };
                    }
                },

                async generateSearchQueries(originalQuery, existingResults, count = 1) {
                    // Generate refined search queries based on current results
                    try {
                        const resultsSummary = existingResults.map((r, i) => `${i + 1}. ${r.title}`).join('\n');
                        const prompt = `Original query: "${originalQuery}"\n\nCurrent search results:\n${resultsSummary}\n\nGenerate ${count} improved search ${count === 1 ? 'query' : 'queries'} to find better information. Return ONLY a JSON array of strings: ["query1"${count > 1 ? ', "query2"' : ''}]`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.7,
                                    maxOutputTokens: 8192,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) return [];
                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '[]';

                        console.log('Query generation raw response:', text);

                        // Try to extract JSON array
                        const jsonStr = this.extractJSON(text) || text.trim();
                        console.log('Extracted query JSON:', jsonStr);

                        const result = JSON.parse(jsonStr);
                        return Array.isArray(result) ? result : [];
                    } catch (e) {
                        console.error('Query generation failed:', e);
                        return [];
                    }
                },

                deduplicateSources(sourcesArray) {
                    // Remove duplicate sources by URL, keeping the first occurrence
                    const seen = new Set();
                    return sourcesArray.filter(source => {
                        if (seen.has(source.url)) return false;
                        seen.add(source.url);
                        return true;
                    });
                },

                async performDeepSearch() {
                    // Perform deep search with 4 total queries
                    const lastAssistantIdx = this.messages.findIndex((m, i) => i === this.messages.length - 1 && m.role === 'assistant');
                    if (lastAssistantIdx === -1) return;

                    const msg = this.messages[lastAssistantIdx];
                    const userQuery = this.messages[lastAssistantIdx - 1]?.content || '';

                    if (!userQuery) return;

                    this.isLoading = true;
                    msg.loading = true;
                    msg.deepSearchPerformed = true;

                    try {
                        let allSources = msg.sources || [];

                        // Generate 3 additional search queries
                        this.searchStatus = 'Generating search strategies...';
                        const newQueries = await this.generateSearchQueries(userQuery, allSources, 3);

                        // Perform 3 more searches
                        for (let i = 0; i < newQueries.length; i++) {
                            this.searchStatus = `Searching (${i + 2}/4)...`;
                            try {
                                const results = await this.searchTavily(newQueries[i]);
                                if (results && results.results) {
                                    const newSources = results.results.map(r => ({
                                        title: r.title || 'Untitled',
                                        url: r.url || '',
                                        content: r.content || ''
                                    }));
                                    allSources = allSources.concat(newSources);
                                }
                            } catch (e) {
                                console.warn(`Search ${i + 2} failed:`, e);
                            }
                        }

                        // Deduplicate and update sources
                        msg.sources = this.deduplicateSources(allSources);

                        // Re-generate answer with all sources
                        this.searchStatus = 'Generating comprehensive answer...';
                        msg.content = '';

                        const contextStr = msg.sources.map((s, i) => `[${i + 1}] Title: ${s.title}\nURL: ${s.url}\nContent: ${s.content.slice(0, 2000)}`).join('\n\n');
                        const prompt = `You are Ka0S_Perplexed, an AI search engine. Answer queries based on the provided context (this is an expanded search with more comprehensive results).

Current Query: ${userQuery}

Expanded Context (from 4 searches):
${contextStr}

Instructions:
- Provide an even more comprehensive answer using all available context.
- Synthesize information from multiple sources.
- Cite your sources using [1], [2] notation inline.
- Use Markdown for formatting.
- Do NOT list sources - they are shown separately.
- Provide a detailed, in-depth response.`;

                        const parts = [{ text: prompt }];
                        await this.streamGemini(parts, (chunk) => {
                            msg.content += chunk;
                        });

                        this.searchStatus = '';
                        this.saveHistory();
                    } catch (error) {
                        console.error('Deep search error:', error);
                        msg.content += `\n\n**Error during deep search:** ${error.message}`;
                        this.searchStatus = '';
                    } finally {
                        this.isLoading = false;
                        msg.loading = false;
                    }
                },

                // API Integrations
                async searchTavily(query) {
                    let adjustedQuery = query;
                    let domains = [];

                    // Focus Mode Logic
                    if (this.focusMode === 'Reddit') {
                        adjustedQuery += ' site:reddit.com';
                        domains = ['reddit.com'];
                    } else if (this.focusMode === 'YouTube') {
                        adjustedQuery += ' site:youtube.com';
                        domains = ['youtube.com'];
                    } else if (this.focusMode === 'Academic') {
                        adjustedQuery += ' academic paper';
                    } else if (this.focusMode === 'Wolfram Alpha') {
                        adjustedQuery += ' wolfram alpha';
                    }

                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.apiKeys.tavily,
                            query: adjustedQuery,
                            search_depth: "basic",
                            include_answer: false,
                            max_results: 7,
                            include_domains: domains.length > 0 ? domains : undefined
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Tavily Search failed');
                    }
                    return await response.json();
                },

                async streamGemini(parts, onChunk) {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?key=${this.apiKeys.gemini}`;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                topP: 0.95,
                                topK: 64,
                                maxOutputTokens: 8192,
                                responseMimeType: 'text/plain'
                            },
                            safetySettings: [
                                {
                                    category: 'HARM_CATEGORY_HARASSMENT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_HATE_SPEECH',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                }
                            ]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Gemini API failed: ${response.status} ${response.statusText} - ${errorText}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // Regex patterns to match text from Gemini stream responses
                        // Matches: "text": "actual text content"
                        // Handles escaped characters within the text
                        const textRegex = /"text"\s*:\s*"((?:[^"\\]|\\.)*)"/g;
                        let match;

                        while ((match = textRegex.exec(chunk)) !== null) {
                            try {
                                // Unescape the captured text
                                const escapedText = match[1];
                                const text = JSON.parse(`"${escapedText}"`);
                                if (text && text.trim()) {
                                    onChunk(text);
                                }
                            } catch (e) {
                                console.warn('Text extraction error:', e.message);
                            }
                        }
                    }
                },

                // Markdown Rendering
                renderMarkdown(text) {
                    // Parse markdown first
                    const rawHtml = marked.parse(text);

                    // Post-process citations [1] -> <a ...>[1]</a>
                    // This must happen after markdown parsing to avoid markdown escaping the HTML
                    const sanitized = DOMPurify.sanitize(rawHtml);
                    const withCitations = sanitized.replace(/\[(\d+)\]/g, '<a href="#source-$1" class="citation-link" title="Source $1">$1</a>');

                    return withCitations;
                }
            }
        }
    </script>
</body>

</html>