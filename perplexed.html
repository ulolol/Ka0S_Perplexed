<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Ka0S_Perplexed</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ€</text></svg>">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        display: ['Space Grotesk', 'sans-serif'],
                        sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
                    },
                    colors: {
                        border: "hsl(var(--border))",
                        input: "hsl(var(--input))",
                        ring: "hsl(var(--ring))",
                        background: "hsl(var(--background))",
                        foreground: "hsl(var(--foreground))",
                        primary: {
                            DEFAULT: "hsl(var(--primary))",
                            foreground: "hsl(var(--primary-foreground))",
                        },
                        secondary: {
                            DEFAULT: "hsl(var(--secondary))",
                            foreground: "hsl(var(--secondary-foreground))",
                        },
                        destructive: {
                            DEFAULT: "hsl(var(--destructive))",
                            foreground: "hsl(var(--destructive-foreground))",
                        },
                        muted: {
                            DEFAULT: "hsl(var(--muted))",
                            foreground: "hsl(var(--muted-foreground))",
                        },
                        accent: {
                            DEFAULT: "hsl(var(--accent))",
                            foreground: "hsl(var(--accent-foreground))",
                        },
                        popover: {
                            DEFAULT: "hsl(var(--popover))",
                            foreground: "hsl(var(--popover-foreground))",
                        },
                        card: {
                            DEFAULT: "hsl(var(--card))",
                            foreground: "hsl(var(--card-foreground))",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                    animation: {
                        'gradient': 'gradient 8s ease infinite',
                        'float': 'float 6s ease-in-out infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'shimmer': 'shimmer 2s linear infinite',
                    },
                    keyframes: {
                        gradient: {
                            '0%, 100%': { backgroundPosition: '0% 50%' },
                            '50%': { backgroundPosition: '100% 50%' },
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        shimmer: {
                            '0%': { backgroundPosition: '-200% 0' },
                            '100%': { backgroundPosition: '200% 0' },
                        }
                    },
                    typography: (theme) => ({
                        DEFAULT: {
                            css: {
                                color: 'hsl(var(--foreground))',
                                a: { color: 'hsl(var(--primary))', '&:hover': { color: 'hsl(var(--primary))' } },
                                code: { color: 'hsl(var(--accent-foreground))', backgroundColor: 'hsl(var(--accent))', borderRadius: '4px', padding: '2px 4px' },
                            },
                        },
                        invert: {
                            css: {
                                color: 'hsl(var(--foreground))',
                                a: { color: 'hsl(var(--primary))', '&:hover': { color: 'hsl(var(--primary))' } },
                            },
                        },
                    }),
                },
            },
        }
    </script>

    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Marked.js for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- DOMPurify -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <style>
        :root {
            /* Light Mode - Zinc/Slate based */
            --background: 210 40% 98%;
            --foreground: 222.2 84% 4.9%;

            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;

            --popover: 0 0% 100%;
            --popover-foreground: 222.2 84% 4.9%;

            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;

            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;

            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;

            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;

            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 210 40% 98%;

            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;

            --radius: 1rem;
        }

        .dark {
            /* Dark Mode - Obsidian Indigo based */
            --background: 240 10% 2%;
            --foreground: 0 0% 98%;

            --card: 240 10% 4%;
            --card-foreground: 0 0% 98%;

            --popover: 240 10% 4%;
            --popover-foreground: 0 0% 98%;

            --primary: 250 85% 65%;
            --primary-foreground: 222.2 47.4% 11.2%;

            --secondary: 240 10% 8%;
            --secondary-foreground: 0 0% 98%;

            --muted: 240 5% 15%;
            --muted-foreground: 240 5% 65%;

            --accent: 250 85% 65% / 0.1;
            --accent-foreground: 250 85% 65%;

            --destructive: 0 84% 60%;
            --destructive-foreground: 210 40% 98%;

            --border: 240 5% 12%;
            --input: 240 5% 15%;
            --ring: 250 85% 65%;
        }

        /* === BASE STYLES === */
        * {
            -webkit-tap-highlight-color: transparent;
            border-color: hsl(var(--border));
        }

        body {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: hsl(var(--muted-foreground) / 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--muted-foreground) / 0.5);
        }

        /* === GLASS SYSTEM REFINED === */
        .glass-panel {
            background: hsl(var(--card) / 0.5);
            backdrop-filter: blur(40px) saturate(200%);
            -webkit-backdrop-filter: blur(40px) saturate(200%);
            border: 1px solid hsl(var(--border) / 0.3);
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.1);
            border-radius: 2rem;
        }

        .glass-card {
            background: hsl(var(--card) / 0.3);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid hsl(var(--border) / 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 1.5rem;
        }

        .glass-card:hover {
            background: hsl(var(--card) / 0.5);
            border-color: hsl(var(--primary) / 0.4);
            transform: translateY(-4px);
            box-shadow: 0 20px 40px -12px rgba(var(--primary), 0.15);
        }

        .glass-input {
            background: hsl(var(--background) / 0.6);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid hsl(var(--border) / 0.4);
            box-shadow: 0 4px 20px -5px rgba(0, 0, 0, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-input:focus-within {
            border-color: hsl(var(--primary) / 0.6);
            box-shadow: 0 0 25px -5px hsl(var(--primary) / 0.3);
            transform: translateY(-1px);
        }

        /* === FLUID ANIMATIONS === */
        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(16px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-12px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                opacity: 0.6;
                box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 40px rgba(56, 189, 248, 0.5);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        .animate-fade-up {
            animation: fadeUp 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .animate-slide-in {
            animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .animate-pulse-glow {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        /* === MODERN COMPONENTS === */
        .btn-primary {
            background: linear-gradient(135deg, #0ea5e9 0%, #38bdf8 50%, #60a5fa 100%);
            color: white;
            font-weight: 500;
            border-radius: 12px;
            padding: 10px 20px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 12px -2px rgba(14, 165, 233, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 20px -4px rgba(14, 165, 233, 0.5);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-ghost {
            border-radius: 10px;
            padding: 8px;
            transition: all 0.2s ease;
        }

        .btn-ghost:hover {
            background: rgba(56, 189, 248, 0.1);
        }

        /* === INPUT AREA WITH SAFE AREA INSETS === */
        .input-area {
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom, 0px));
            background: linear-gradient(to top, rgba(15, 23, 42, 0.95) 0%, rgba(15, 23, 42, 0.8) 60%, transparent 100%);
        }

        .light .input-area {
            background: linear-gradient(to top, rgba(240, 249, 255, 0.95) 0%, rgba(240, 249, 255, 0.8) 60%, transparent 100%);
        }

        /* === CHAT CONTENT WITH SAFE AREA INSETS === */
        .chat-content {
            padding-bottom: calc(12rem + env(safe-area-inset-bottom, 0px));
        }

        /* === CHAT ITEM === */
        .chat-item {
            border-radius: 9999px;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .chat-item:hover {
            background: rgba(56, 189, 248, 0.08);
        }

        .chat-item.active {
            background: rgba(56, 189, 248, 0.12);
        }

        .chat-item.active::before {
            content: '';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 50%;
            background: linear-gradient(180deg, #0ea5e9, #38bdf8);
            border-radius: 9999px;
        }

        /* === SOURCE CARD === */
        .source-card {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 14px;
            padding: 14px;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .source-card:hover {
            background: rgba(51, 65, 85, 0.6);
            border-color: rgba(56, 189, 248, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 12px 32px -8px rgba(56, 189, 248, 0.15);
        }

        .light .source-card {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.8) 0%, rgba(241, 245, 249, 0.7) 100%);
            border: 2px solid rgba(203, 213, 225, 0.4);
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.03),
                0 0 20px rgba(203, 213, 225, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .light .source-card:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.8) 100%);
            border-color: rgba(251, 191, 36, 0.5);
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.05),
                0 0 30px rgba(251, 191, 36, 0.3),
                0 0 50px rgba(56, 189, 248, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.95);
        }

        /* Light mode accent button with gold */
        .light .btn-primary {
            background: linear-gradient(135deg, #0284c7 0%, #38bdf8 40%, #e2e8f0 70%, #fbbf24 100%);
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.4), 0 0 30px rgba(56, 189, 248, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .light .btn-primary:hover {
            box-shadow: 0 8px 30px rgba(251, 191, 36, 0.5), 0 0 40px rgba(56, 189, 248, 0.3);
            transform: translateY(-2px);
        }

        .light .chat-item.active::before {
            background: linear-gradient(180deg, #0ea5e9, #fbbf24);
        }

        .light .accent-gold {
            color: #f59e0b;
        }

        /* === TOUCH TARGET === */
        .touch-target {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* === DELETE BUTTON === */
        .delete-btn {
            opacity: 1;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
            color: #71717a;
        }

        .delete-btn:hover {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        @media (min-width: 768px) {
            .delete-btn {
                opacity: 0;
            }

            .chat-item:hover .delete-btn,
            .chat-item:focus-within .delete-btn {
                opacity: 1;
            }
        }

        /* === REDUCED MOTION === */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* === MARKDOWN STYLES === */
        .prose p {
            margin-bottom: 1em;
        }

        .prose ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        .prose ol {
            list-style-type: decimal;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        .prose h1,
        .prose h2,
        .prose h3 {
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        .prose h1 {
            font-size: 1.5em;
        }

        .prose h2 {
            font-size: 1.25em;
        }

        .prose h3 {
            font-size: 1.1em;
        }

        .prose code {
            background: rgba(99, 102, 241, 0.1);
            padding: 0.2em 0.5em;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
        }

        .prose pre {
            background: rgba(24, 24, 27, 0.8);
            padding: 1em;
            border-radius: 12px;
            overflow-x: auto;
            margin-bottom: 1em;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .prose pre code {
            background: transparent;
            padding: 0;
        }

        .prose blockquote {
            border-left: 3px solid #6366f1;
            padding-left: 1em;
            margin: 1em 0;
            color: #a1a1aa;
        }

        /* === CITATION === */
        .citation-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.3em;
            height: 1.3em;
            border-radius: 6px;
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 0.15em;
            text-decoration: none;
            vertical-align: super;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .citation-link:hover {
            background: #6366f1;
            color: white;
        }
    </style>
</head>

<body
    class="bg-mesh text-light-text dark:text-dark-text h-screen flex overflow-hidden font-sans selection:bg-accent selection:text-white antialiased"
    x-data="app()" x-init="initApp()">

    <!-- Sidebar -->
    <aside class="w-72 glass-panel flex-col hidden md:flex rounded-[2rem] my-3 ml-3 shadow-2xl border-white/5">
        <div class="px-5 py-8 flex flex-col gap-8">
            <!-- Branding -->
            <div class="flex items-center gap-3 px-2">
                <div
                    class="w-10 h-10 rounded-2xl bg-gradient-to-tr from-blue-500 to-purple-600 flex items-center justify-center shadow-lg shadow-blue-500/20 rotate-3">
                    <i data-lucide="sparkles" class="w-5 h-5 text-white"></i>
                </div>
                <span class="font-display font-bold text-lg tracking-tight">Ka0S_Perplexed</span>
            </div>

            <!-- New Chat Button -->
            <button @click="startNewChat()"
                class="w-full bg-gradient-to-r from-orange-500 via-pink-500 to-rose-500 text-white font-bold py-4 px-6 rounded-2xl flex items-center justify-center gap-2 shadow-xl shadow-pink-500/20 hover:scale-[1.02] active:scale-95 transition-all duration-300">
                <i data-lucide="plus" class="w-5 h-5"></i>
                <span>New Chat</span>
            </button>
        </div>

        <div class="flex-1 overflow-y-auto px-4 space-y-2 pb-6">
            <div class="text-[10px] font-bold text-muted-foreground uppercase tracking-[0.2em] px-3 mb-2 opacity-50">
                Recent Activity</div>
            <template x-for="chat in history" :key="chat.id">
                <div class="chat-item group flex items-center gap-2 p-2.5 rounded-xl cursor-pointer transition-all duration-200 hover:bg-muted/50"
                    :class="{ 'bg-muted font-medium text-foreground': currentChatId === chat.id, 'text-muted-foreground': currentChatId !== chat.id }"
                    @click="loadChat(chat.id)">
                    <i data-lucide="message-square" class="w-4 h-4 opacity-70"></i>
                    <span x-text="chat.title || 'New Chat'" class="text-sm truncate flex-1"></span>
                    <button @click.stop="deleteChat(chat.id)"
                        class="delete-btn opacity-0 group-hover:opacity-100 p-1.5 rounded-md hover:bg-destructive/10 hover:text-destructive transition-all"
                        title="Delete chat">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </div>
            </template>
        </div>

        <div class="p-4 border-t border-border/40">
            <button @click="showSettings = true"
                class="flex items-center gap-3 w-full p-3 rounded-xl hover:bg-muted/50 transition-colors text-sm font-medium text-muted-foreground hover:text-foreground">
                <i data-lucide="settings" class="w-4 h-4"></i>
                Settings
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col h-full relative">
        <!-- Mobile Header -->
        <header
            class="md:hidden flex items-center justify-between p-4 glass-panel z-10 mx-2 mt-2 rounded-2xl border-white/5 shadow-2xl">
            <div class="flex items-center gap-3">
                <div
                    class="w-9 h-9 rounded-xl bg-gradient-to-tr from-blue-500 to-purple-600 flex items-center justify-center shadow-lg shadow-blue-500/20 rotate-3">
                    <i data-lucide="sparkles" class="w-4 h-4 text-white"></i>
                </div>
                <span class="font-display font-bold tracking-tight">Ka0S_Perplexed</span>
            </div>
            <button @click="mobileMenuOpen = !mobileMenuOpen"
                class="btn-ghost p-2 hover:bg-primary/10 rounded-xl transition-all">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>
        </header>

        <!-- Mobile Menu Overlay -->
        <div x-show="mobileMenuOpen" class="absolute inset-0 bg-black/70 backdrop-blur-sm z-40 md:hidden"
            @click="mobileMenuOpen = false" x-transition.opacity>
        </div>

        <!-- Mobile Menu Panel -->
        <div x-show="mobileMenuOpen"
            class="absolute top-2 bottom-2 left-0 w-80 glass-panel z-50 transform md:hidden flex flex-col rounded-r-3xl"
            x-transition:enter="transition ease-out duration-300" x-transition:enter-start="-translate-x-full"
            x-transition:enter-end="translate-x-0" x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="translate-x-0" x-transition:leave-end="-translate-x-full">
            <div class="p-6 flex items-center justify-between border-b border-white/5">
                <div class="flex items-center gap-3">
                    <div
                        class="w-8 h-8 rounded-xl bg-gradient-to-tr from-blue-500 to-purple-600 flex items-center justify-center shadow-lg shadow-blue-500/10 rotate-3">
                        <i data-lucide="sparkles" class="w-3.5 h-3.5 text-white"></i>
                    </div>
                    <span class="font-display font-bold text-lg tracking-tight">Ka0S_Perplexed</span>
                </div>
                <button @click="mobileMenuOpen = false"
                    class="btn-ghost p-2 hover:bg-destructive/10 hover:text-destructive rounded-xl transition-all">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <div class="p-6 flex-1 flex flex-col min-h-0">
                <button @click="startNewChat(); mobileMenuOpen = false"
                    class="w-full bg-gradient-to-r from-orange-500 via-pink-500 to-rose-500 text-white font-bold py-4 px-6 rounded-2xl flex items-center justify-center gap-2 shadow-xl shadow-pink-500/20 hover:scale-[1.02] active:scale-95 transition-all duration-300 mb-6 shrink-0">
                    <i data-lucide="plus" class="w-5 h-5"></i>
                    <span>New Chat</span>
                </button>
                <div
                    class="text-[10px] font-bold text-muted-foreground uppercase tracking-[0.2em] px-3 mb-2 opacity-50 shrink-0">
                    Recent Activity</div>
                <div class="space-y-2 overflow-y-auto flex-1 pr-1">
                    <template x-for="chat in history" :key="chat.id">
                        <div class="chat-item group flex items-center gap-2 p-3 rounded-xl cursor-pointer transition-all duration-200 hover:bg-muted/50"
                            :class="{ 'bg-muted font-medium text-foreground': currentChatId === chat.id, 'text-muted-foreground': currentChatId !== chat.id }"
                            @click="loadChat(chat.id); mobileMenuOpen = false">
                            <i data-lucide="message-square" class="w-4 h-4 opacity-70"></i>
                            <span x-text="chat.title || 'New Chat'" class="text-sm truncate flex-1"></span>
                            <button @click.stop="deleteChat(chat.id)"
                                class="delete-btn p-1.5 hover:bg-destructive/10 hover:text-destructive transition-all"
                                title="Delete chat">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </template>
                </div>
            </div>
            <div class="p-6 border-t border-white/5 bg-card/20 backdrop-blur-md rounded-b-3xl">
                <button @click="showSettings = true; mobileMenuOpen = false"
                    class="flex items-center gap-3 w-full p-4 rounded-xl hover:bg-muted/50 transition-colors text-sm font-semibold text-muted-foreground hover:text-foreground">
                    <i data-lucide="settings" class="w-5 h-5"></i>
                    Settings
                </button>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="flex-1 overflow-y-auto p-4 md:p-8 scroll-smooth" id="chat-container">
            <div class="max-w-3xl mx-auto space-y-8 chat-content">

                <!-- Welcome Screen -->
                <!-- Welcome Screen (Mockup Layout) -->
                <div x-show="messages.length === 0"
                    class="flex flex-col items-center justify-center min-h-[70vh] py-12 animate-fade-up">
                    <div
                        class="glass-panel w-full max-w-2xl p-8 md:p-12 space-y-10 relative overflow-hidden group/panel">
                        <!-- Abstract Background Glows -->
                        <div
                            class="absolute -top-24 -left-24 w-48 h-48 bg-primary/20 rounded-full blur-[80px] pointer-events-none">
                        </div>
                        <div
                            class="absolute -bottom-24 -right-24 w-48 h-48 bg-primary/10 rounded-full blur-[80px] pointer-events-none">
                        </div>

                        <!-- Branding -->
                        <div class="flex flex-col items-center gap-6 relative z-10">
                            <!-- Colorful Icon (Hexagon Style) -->
                            <div class="w-20 h-20 relative animate-float">
                                <div
                                    class="absolute inset-0 bg-gradient-to-tr from-blue-500 via-purple-500 to-pink-500 rounded-2xl rotate-12 blur-sm opacity-50">
                                </div>
                                <div
                                    class="relative bg-white dark:bg-zinc-900 w-full h-full rounded-2xl flex items-center justify-center shadow-2xl border border-white/20">
                                    <i data-lucide="sparkles" class="w-10 h-10 text-primary"></i>
                                </div>
                            </div>
                            <h1 class="font-display text-4xl md:text-5xl font-bold tracking-tight text-foreground">
                                What is knowledge?
                            </h1>
                        </div>

                        <!-- Suggested Cards -->
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 relative z-10">
                            <template x-for="suggestion in [
                                { icon: 'zap', title: 'Recent AI breakthroughs', sub: 'Read on...' },
                                { icon: 'book-open', title: 'Philosophy of mind', sub: 'Read on...' },
                                { icon: 'cpu', title: 'Future of Agentic AI', sub: 'Read on...' }
                            ]" :key="suggestion.title">
                                <button @click="input = suggestion.title; sendMessage()"
                                    class="glass-card p-5 text-left group/card hover:scale-105 transition-all duration-500 flex flex-col gap-3 min-h-[120px]">
                                    <div
                                        class="w-10 h-10 rounded-xl bg-primary/10 flex items-center justify-center text-primary group-hover/card:bg-primary group-hover/card:text-white transition-all duration-500">
                                        <i :data-lucide="suggestion.icon" class="w-5 h-5"></i>
                                    </div>
                                    <div class="space-y-1">
                                        <div class="text-sm font-semibold text-foreground line-clamp-2"
                                            x-text="suggestion.title"></div>
                                        <div class="text-[10px] text-muted-foreground font-medium uppercase tracking-wider"
                                            x-text="suggestion.sub"></div>
                                    </div>
                                </button>
                            </template>
                        </div>

                        <!-- Inline Search Pill (Visible only in Welcome) -->
                        <div class="relative z-10 pt-4">
                            <div
                                class="glass-input rounded-full px-4 py-2 flex items-center gap-2 border-primary/30 shadow-lg shadow-primary/5">
                                <div class="flex items-center gap-3">
                                    <button
                                        class="flex items-center gap-1.5 text-sm font-medium text-muted-foreground hover:text-primary transition-colors py-1">
                                        <span x-text="focusMode">All</span>
                                        <i data-lucide="chevron-down" class="w-3.5 h-3.5"></i>
                                    </button>
                                    <div class="h-5 w-px bg-border/40"></div>
                                    <button class="text-muted-foreground hover:text-primary transition-colors p-1.5">
                                        <i data-lucide="paperclip" class="w-5 h-5"></i>
                                    </button>
                                </div>
                                <textarea x-model="input" @keydown.enter.prevent="if(!$event.shiftKey) sendMessage()"
                                    placeholder="Ask anything..."
                                    class="flex-1 bg-transparent border-none focus:ring-0 focus:outline-none outline-none resize-none max-h-48 min-h-[44px] py-2.5 text-base placeholder:text-muted-foreground/40"
                                    rows="1"
                                    @input="$el.style.height = 'auto'; $el.style.height = $el.scrollHeight + 'px'"></textarea>
                                <button @click="sendMessage()" :disabled="!input.trim() || isLoading"
                                    class="bg-primary text-primary-foreground hover:bg-primary/90 p-2.5 rounded-full shadow-lg shadow-primary/20 w-10 min-w-[40px] h-10 flex items-center justify-center transition-all active:scale-95">
                                    <i data-lucide="arrow-up" class="w-5 h-5"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Messages -->
                <template x-for="(msg, index) in messages" :key="index">
                    <div class="animate-fade-up space-y-5">
                        <!-- User Message -->
                        <div x-show="msg.role === 'user'" class="flex flex-col space-y-2">
                            <h2 class="text-2xl font-display font-semibold tracking-tight" x-text="msg.content"></h2>
                        </div>

                        <!-- Assistant Message -->
                        <div x-show="msg.role === 'assistant'" class="flex flex-col space-y-5">

                            <!-- Sources Grid -->
                            <div x-show="msg.sources && msg.sources.length > 0" class="space-y-3">
                                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    <template x-for="(source, idx) in (msg.sources || []).slice(0, 7)" :key="idx">
                                        <a :href="source.url" target="_blank" class="source-card block">
                                            <div class="font-medium mb-1.5 truncate text-sm" x-text="source.title">
                                            </div>
                                            <div class="flex items-center gap-2 text-muted-foreground">
                                                <div class="w-5 h-5 rounded-md bg-primary/10 flex items-center justify-center text-[10px] font-bold text-primary"
                                                    x-text="idx + 1"></div>
                                                <span class="truncate text-xs"
                                                    x-text="new URL(source.url).hostname"></span>
                                            </div>
                                        </a>
                                    </template>
                                </div>
                                <!-- Search Deeper Button -->
                                <button @click="performDeepSearch()"
                                    x-show="!msg.deepSearchPerformed && !isLoading && msg.role === 'assistant'"
                                    class="inline-flex items-center gap-2 text-sm px-4 py-2.5 glass-card text-primary hover:text-primary/80 rounded-xl font-medium transition-colors">
                                    <i data-lucide="search" class="w-4 h-4"></i>
                                    Search Deeper
                                </button>
                            </div>

                            <!-- Answer Content -->
                            <div class="flex gap-4">
                                <div class="flex-shrink-0 mt-1">
                                    <div
                                        class="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center text-primary">
                                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                                    </div>
                                </div>
                                <div class="prose dark:prose-invert max-w-none w-full"
                                    x-html="renderMarkdown(msg.content)"></div>
                            </div>

                            <!-- Selected Images Grid -->
                            <div x-show="msg.selectedImages && msg.selectedImages.length > 0" class="ml-10 space-y-3">
                                <div
                                    class="text-xs text-muted-foreground font-semibold flex items-center gap-1.5 uppercase tracking-wider">
                                    <i data-lucide="image" class="w-3.5 h-3.5"></i>
                                    Relevant Images
                                </div>
                                <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
                                    <template x-for="(img, idx) in (msg.selectedImages || [])" :key="idx">
                                        <a :href="img.url" target="_blank"
                                            class="source-card group relative rounded-xl overflow-hidden">
                                            <img :src="img.url" :alt="img.description || 'Search result image'"
                                                class="w-full h-32 object-cover bg-dark-surface"
                                                @error="$el.parentElement.style.display='none'">
                                            <div
                                                class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity flex items-end p-3">
                                                <span class="text-white text-xs line-clamp-2 font-medium"
                                                    x-text="img.description || 'View image'"></span>
                                            </div>
                                        </a>
                                    </template>
                                </div>
                            </div>

                            <!-- Loading Indicator -->
                            <div x-show="msg.loading" class="flex items-center gap-3 text-muted-foreground ml-10">
                                <div class="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center">
                                    <i data-lucide="loader-2" class="w-4 h-4 animate-spin text-primary"></i>
                                </div>
                                <span class="text-sm font-medium" x-text="searchStatus || 'Thinking...'"></span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Input Area (Footer - Visible only when chatting) -->
        <div x-show="messages.length > 0" x-transition:enter="transition ease-out duration-500"
            x-transition:enter-start="opacity-0 translateY(20px)" x-transition:enter-end="opacity-100 translateY(0)"
            class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-transparent via-transparent to-transparent pt-8 px-4 z-20 input-area">
            <div class="max-w-3xl mx-auto">
                <div
                    class="glass-input rounded-full px-4 py-2 flex items-center gap-2 group transition-all duration-300 focus-within:ring-2 focus-within:ring-primary/20">
                    <!-- Left Side Controls -->
                    <div class="flex items-center gap-3">
                        <!-- Focus Mode Dropdown -->
                        <div class="relative" x-data="{ open: false }">
                            <button @click="open = !open"
                                class="flex items-center gap-1.5 text-sm font-medium text-muted-foreground hover:text-primary transition-colors py-1">
                                <span x-text="focusMode"></span>
                                <i data-lucide="chevron-down" class="w-3.5 h-3.5"></i>
                            </button>
                            <div x-show="open" @click.outside="open = false"
                                class="absolute bottom-full left-0 mb-3 w-48 glass-panel rounded-2xl shadow-2xl overflow-hidden z-50">
                                <template x-for="mode in focusModes" :key="mode">
                                    <button @click="focusMode = mode; open = false"
                                        class="w-full text-left px-4 py-3 text-sm hover:bg-primary/10 transition-colors first:rounded-t-2xl last:rounded-b-2xl"
                                        x-text="mode"></button>
                                </template>
                            </div>
                        </div>

                        <!-- Separator -->
                        <div class="h-5 w-px bg-border/40"></div>

                        <!-- File Upload -->
                        <button type="button" @click="$refs.fileInput?.click()"
                            class="text-muted-foreground hover:text-primary transition-colors p-1.5"
                            :title="selectedFiles.length ? (selectedFiles.length + ' file' + (selectedFiles.length > 1 ? 's' : '') + ' selected') : 'Attach files/images'">
                            <i data-lucide="paperclip" class="w-5 h-5"></i>
                            <span x-show="selectedFiles.length"
                                class="absolute -top-1 -right-1 text-[10px] bg-primary text-primary-foreground w-4 h-4 rounded-full flex items-center justify-center font-semibold scale-75"
                                x-text="selectedFiles.length"></span>
                        </button>
                        <input x-ref="fileInput" type="file" multiple
                            accept="image/*,application/pdf,text/plain,.txt,.md,application/json,video/*"
                            @change="handleFiles($event)" class="hidden">
                    </div>

                    <!-- Input Area -->
                    <textarea x-model="input" @keydown.enter.prevent="if(!$event.shiftKey) sendMessage()"
                        placeholder="Ask anything..."
                        class="flex-1 bg-transparent border-none focus:ring-0 focus:outline-none outline-none resize-none max-h-48 min-h-[44px] py-2.5 text-base placeholder:text-muted-foreground/50"
                        rows="1" x-ref="inputArea"
                        @input="$el.style.height = 'auto'; $el.style.height = $el.scrollHeight + 'px'"></textarea>

                    <!-- Right Side Controls (Send) -->
                    <button @click="sendMessage()" :disabled="!input.trim() || isLoading"
                        class="bg-primary text-primary-foreground hover:bg-primary/90 p-2.5 rounded-full disabled:opacity-50 disabled:cursor-not-allowed transition-all active:scale-95 shadow-lg shadow-primary/20 flex items-center justify-center w-10 min-w-[40px] h-10">
                        <i data-lucide="arrow-up" class="w-5 h-5"></i>
                    </button>
                </div>

                <!-- Attached Files Preview (Outside the pill but inside the wrapper for positioning) -->
                <div x-show="filePreviews.length"
                    class="mt-3 px-2 space-y-2 max-h-32 overflow-y-auto w-full animate-fade-up">
                    <template x-for="preview in filePreviews" :key="preview.id">
                        <div class="flex items-center gap-3 p-3 glass-card rounded-2xl border border-primary/10">
                            <template x-if="preview.type?.startsWith('image/')">
                                <img :src="'data:' + preview.type + ';base64,' + preview.data"
                                    class="w-10 h-10 object-cover rounded-lg" :alt="preview.name">
                            </template>
                            <template x-else>
                                <div
                                    class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center text-primary">
                                    <i data-lucide="file-text" class="w-5 h-5"></i>
                                </div>
                            </template>
                            <span class="text-xs flex-1 min-w-0 truncate font-semibold" x-text="preview.name"></span>
                            <span class="text-[10px] text-muted-foreground font-medium uppercase tracking-wider"
                                x-text="(preview.size / 1024).toFixed(1) + ' KB'"></span>
                            <button @click="removeFile(preview.id)"
                                class="text-muted-foreground hover:text-destructive p-2 hover:bg-destructive/10 rounded-xl transition-colors">
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </template>
                </div>
            </div>
            <div class="text-center mt-3 text-xs text-dark-muted/60 font-medium">
                Powered by Tavily & Gemini â€¢ Local Storage Only
            </div>
        </div>
        </div>
    </main>

    <!-- Settings Modal -->
    <div x-show="showSettings"
        class="fixed inset-0 bg-black/70 backdrop-blur-md z-50 flex items-center justify-center p-4"
        x-transition.opacity>
        <div class="glass-panel w-full max-w-md rounded-2xl shadow-card overflow-hidden"
            @click.outside="showSettings = false">
            <div class="p-5 border-b border-dark-border/30 flex items-center justify-between">
                <h2 class="font-display font-bold text-lg">Settings</h2>
                <button @click="showSettings = false"
                    class="btn-ghost p-2 rounded-lg hover:bg-destructive/10 hover:text-destructive transition-colors">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <div class="p-6 space-y-6">
                <!-- Theme Toggle -->
                <div class="flex items-center justify-between">
                    <span class="font-medium" :class="isDark ? 'text-dark-text' : 'text-[#0c4a6e]'">Dark Mode</span>
                    <button @click="toggleTheme()"
                        class="w-14 h-7 rounded-full relative transition-colors cursor-pointer"
                        :class="isDark ? 'bg-slate-700' : 'bg-sky-200'">
                        <div class="w-5 h-5 rounded-full absolute top-1 transition-all duration-200 shadow-lg"
                            :class="isDark ? 'left-8 bg-gradient-to-r from-sky-400 to-amber-400' : 'left-1 bg-gradient-to-r from-white to-amber-200'">
                        </div>
                    </button>
                </div>

                <!-- API Keys -->
                <div class="space-y-4">
                    <h3 class="font-semibold text-sm text-dark-muted uppercase tracking-wider">API Keys</h3>

                    <div class="space-y-2">
                        <label class="text-sm font-medium">Tavily API Key</label>
                        <input type="password" x-model="apiKeys.tavily"
                            class="w-full glass-input rounded-xl p-3 text-sm focus:ring-0 outline-none"
                            placeholder="tvly-...">
                    </div>

                    <div class="space-y-2">
                        <label class="text-sm font-medium">Gemini API Key</label>
                        <input type="password" x-model="apiKeys.gemini"
                            class="w-full glass-input rounded-xl p-3 text-sm focus:ring-0 outline-none"
                            placeholder="AIza...">
                    </div>

                    <div class="pt-2">
                        <label
                            class="text-xs text-accent hover:text-accent-light cursor-pointer font-medium transition-colors">
                            Load from api-keys-example.json
                            <input type="file" accept=".json" @change="loadKeysFromFile($event)" class="hidden">
                        </label>
                    </div>
                </div>
            </div>
            <div class="p-4 border-t border-dark-border/30 bg-dark-surface/50 flex justify-end">
                <button @click="saveSettings()" class="btn-primary">Save & Close</button>
            </div>
        </div>
    </div>

    <script>
        function app() {
            return {
                // State
                history: [],
                messages: [],
                currentChatId: null,
                input: '',
                isLoading: false,
                isDark: true,
                showSettings: false,
                mobileMenuOpen: false,
                focusMode: 'All',
                focusModes: ['All', 'Academic', 'Reddit', 'Writing Assistant', 'Wolfram Alpha'],
                selectedFiles: [],
                filePreviews: [],
                apiKeys: {
                    tavily: '',
                    gemini: ''
                },
                searchDeeper: false,
                searchStatus: '',
                dateTimeCache: null,

                // Initialization
                initApp() {
                    // Load Theme
                    const savedTheme = localStorage.getItem('perplexica.theme');
                    this.isDark = savedTheme ? savedTheme === 'dark' : true;
                    this.applyTheme();

                    // Load Keys
                    const savedKeys = localStorage.getItem('perplexica.keys');
                    if (savedKeys) {
                        this.apiKeys = JSON.parse(savedKeys);
                    }
                    // Auto-load from api-keys-example.json (only if not opened via file://)
                    if (!location.protocol.startsWith('file')) {
                        fetch('./api-keys-example.json')
                            .then(r => r.ok ? r.json() : null)
                            .then(data => {
                                if (data) {
                                    Object.assign(this.apiKeys, data);
                                    localStorage.setItem('perplexica.keys', JSON.stringify(this.apiKeys));
                                }
                            })
                            .catch(e => {
                                // Silently ignore errors (file may not exist or network issues)
                            });
                    }

                    // Load History
                    const savedHistory = localStorage.getItem('perplexica.history');
                    if (savedHistory) {
                        this.history = JSON.parse(savedHistory);
                    }

                    // Start new chat if empty
                    if (this.history.length === 0) {
                        this.startNewChat();
                    } else {
                        // Load most recent
                        this.loadChat(this.history[0].id);
                    }
                },

                // Theme Logic
                toggleTheme() {
                    this.isDark = !this.isDark;
                    this.applyTheme();
                    localStorage.setItem('perplexica.theme', this.isDark ? 'dark' : 'light');
                },
                applyTheme() {
                    const html = document.documentElement;
                    if (this.isDark) {
                        html.classList.add('dark');
                        html.classList.remove('light');
                    } else {
                        html.classList.remove('dark');
                        html.classList.add('light');
                    }
                },

                // Settings Logic
                saveSettings() {
                    localStorage.setItem('perplexica.keys', JSON.stringify(this.apiKeys));
                    this.showSettings = false;
                },
                async loadKeysFromFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        if (data.tavily || data.gemini) {
                            this.apiKeys = { ...this.apiKeys, ...data };
                            alert('Keys loaded! Click Save to persist.');
                        } else {
                            throw new Error('Invalid JSON format');
                        }
                    } catch (e) {
                        alert('Error loading file: ' + e.message);
                    }
                    // Reset input
                    event.target.value = '';
                },

                // Chat Management
                startNewChat() {
                    const newChat = {
                        id: Date.now().toString(),
                        title: 'New Chat',
                        messages: [],
                        timestamp: Date.now()
                    };
                    this.history.unshift(newChat);
                    this.currentChatId = newChat.id;
                    this.messages = [];
                    this.saveHistory();
                    this.$nextTick(() => {
                        this.refreshIcons();
                    });
                },
                refreshIcons() {
                    if (window.lucide) {
                        setTimeout(() => window.lucide.createIcons(), 50);
                    }
                },
                loadChat(id) {
                    const chat = this.history.find(c => c.id === id);
                    if (chat) {
                        this.currentChatId = id;
                        this.messages = chat.messages.map(m => ({
                            ...m,
                            sources: m.sources || [],
                            selectedImages: m.selectedImages || []
                        }));
                        // Scroll to bottom
                        this.$nextTick(() => {
                            const container = document.getElementById('chat-container');
                            container.scrollTop = container.scrollHeight;
                            this.refreshIcons();
                        });
                    }
                },
                deleteChat(id) {
                    this.history = this.history.filter(c => c.id !== id);
                    if (this.currentChatId === id) {
                        if (this.history.length > 0) {
                            this.loadChat(this.history[0].id);
                        } else {
                            this.startNewChat();
                        }
                    }
                    this.saveHistory();
                },
                saveHistory() {
                    // Update current chat messages
                    const chatIndex = this.history.findIndex(c => c.id === this.currentChatId);
                    if (chatIndex !== -1) {
                        this.history[chatIndex].messages = this.messages;
                        // Generate title if new
                        if (this.messages.length > 0 && this.history[chatIndex].title === 'New Chat') {
                            this.history[chatIndex].title = this.messages[0].content.slice(0, 30) + '...';
                        }
                    }
                    localStorage.setItem('perplexica.history', JSON.stringify(this.history));
                },

                // System Grounding Functions
                async fetchCurrentDateTime() {
                    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

                    // Check cache
                    if (this.dateTimeCache && Date.now() - this.dateTimeCache.timestamp < CACHE_DURATION) {
                        return this.dateTimeCache.data;
                    }

                    try {
                        // Try WorldTimeAPI with 3s timeout
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 3000);

                        const response = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC', {
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            const data = await response.json();
                            const result = {
                                datetime: data.datetime,
                                utc_datetime: data.utc_datetime,
                                timezone: 'UTC',
                                formatted: new Date(data.datetime).toUTCString()
                            };

                            this.dateTimeCache = { data: result, timestamp: Date.now() };
                            return result;
                        }
                    } catch (e) {
                        console.warn('WorldTimeAPI unavailable, using client time:', e.message);
                    }

                    // Fallback to client time
                    const now = new Date();
                    const result = {
                        datetime: now.toISOString(),
                        utc_datetime: now.toISOString(),
                        timezone: 'UTC (client)',
                        formatted: now.toUTCString()
                    };

                    this.dateTimeCache = { data: result, timestamp: Date.now() };
                    return result;
                },

                async buildSystemGroundingContext(includeConversation = false) {
                    const dateTime = await this.fetchCurrentDateTime();

                    let context = `
=== SYSTEM CONTEXT ===
Current Date & Time: ${dateTime.formatted}
Your Knowledge Cutoff: April 2024
Focus Mode: ${this.focusMode}
Session: Ka0S_Perplexed v1.0
===`;

                    if (includeConversation && this.messages.length > 1) {
                        const recentMessages = this.messages.slice(-6);
                        context += `\n\nRecent Conversation (last ${Math.min(6, this.messages.length - 1)} exchanges):`;
                        recentMessages.forEach(msg => {
                            if (msg.role === 'user') {
                                context += `\nUser: ${msg.content.slice(0, 200)}`;
                            } else if (msg.role === 'assistant') {
                                context += `\nAssistant: ${msg.content.slice(0, 200)}...`;
                            }
                        });
                    }

                    return context;
                },

                // File handling methods
                async handleFiles(event) {
                    const files = Array.from(event.target.files);
                    const newFiles = [];
                    const newPreviews = [];
                    for (let i = 0; i < files.length && newFiles.length < 5; i++) {
                        const file = files[i];
                        if (file.size > 8 * 1024 * 1024) continue; // 8MB limit
                        let processed = null;
                        if (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('video/')) {
                            try {
                                const base64 = await this.fileToBase64(file);
                                processed = {
                                    id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    name: file.name,
                                    type: file.type,
                                    data: base64,
                                    content: null,
                                    size: file.size
                                };
                            } catch (e) {
                                console.warn('Failed to read file:', file.name, e);
                            }
                        } else {
                            try {
                                const content = await file.text();
                                processed = {
                                    id: `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    name: file.name,
                                    type: file.type,
                                    data: null,
                                    content: content.slice(0, 20000), // 20k chars max
                                    size: file.size
                                };
                            } catch (e) {
                                console.warn('Failed to read text file:', file.name, e);
                            }
                        }
                        if (processed) {
                            newFiles.push(processed);
                            newPreviews.push({ ...processed, type: processed.type || 'text' });
                        }
                    }
                    this.selectedFiles = newFiles;
                    this.filePreviews = newPreviews;
                    event.target.value = '';
                    this.$nextTick(() => this.refreshIcons());
                },
                fileToBase64(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result.split(',')[1]);
                        reader.onerror = () => reject(new Error('Failed to read file'));
                        reader.readAsDataURL(file);
                    });
                },
                blobToBase64(blob) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result.split(',')[1]);
                        reader.onerror = () => reject(new Error('Failed to read blob'));
                        reader.readAsDataURL(blob);
                    });
                },

                removeFile(id) {
                    this.selectedFiles = this.selectedFiles.filter(f => f.id !== id);
                    this.filePreviews = this.filePreviews.filter(p => p.id !== id);
                    this.$nextTick(() => this.refreshIcons());
                },

                // Messaging Logic
                async sendMessage() {
                    if (!this.input.trim() || this.isLoading) return;

                    if (!this.apiKeys.gemini) {
                        alert('Please set your Gemini API Key in Settings.');
                        this.showSettings = true;
                        return;
                    }

                    const userQuery = this.input.trim();
                    this.input = '';
                    this.$refs.inputArea.style.height = 'auto';

                    // Add User Message
                    this.messages.push({
                        role: 'user',
                        content: userQuery
                    });

                    // Add Placeholder Assistant Message
                    const assistantMsgIndex = this.messages.push({
                        role: 'assistant',
                        content: '',
                        sources: [],
                        selectedImages: [],
                        loading: true
                    }) - 1;

                    this.isLoading = true;
                    this.$nextTick(() => {
                        const container = document.getElementById('chat-container');
                        container.scrollTop = container.scrollHeight;
                        this.refreshIcons();
                    });

                    try {
                        let sources = [];
                        let allImages = [];
                        let prompt = '';

                        // Build conversation history
                        let conversationHistory = '';
                        if (this.messages.length > 1) {
                            for (let i = 0; i < this.messages.length - 1; i++) {
                                const msg = this.messages[i];
                                if (msg.role === 'user') {
                                    conversationHistory += `\nUser: ${msg.content}\n`;
                                } else if (msg.role === 'assistant') {
                                    const content = msg.content.slice(0, 500) + (msg.content.length > 500 ? '...' : '');
                                    conversationHistory += `Assistant: ${content}\n`;
                                }
                            }
                        }

                        // 1. Content Analysis (if files attached)
                        let contentAnalysis = null;
                        if (this.selectedFiles.length > 0) {
                            contentAnalysis = await this.analyzeAttachmentsAndGenerateQueries(this.selectedFiles, userQuery);
                        }

                        // 2. Determine Search Needs (The "Reasoning Loop" Start)
                        let searchQueriesToUse = [];
                        let needsSearch = false;

                        // If files are attached, we might still need web search, but let's check the plan
                        // If specific focus mode (like Writing Assistant), we might skip this, but let's stick to the plan for "All"
                        if (this.focusMode === 'Writing Assistant') {
                            needsSearch = false;
                        } else if (this.apiKeys.tavily) {
                            const searchPlan = await this.determineSearchNeeds(userQuery, conversationHistory);
                            console.log('Search Plan:', searchPlan);

                            if (searchPlan.needsSearch) {
                                needsSearch = true;
                                searchQueriesToUse = searchPlan.searchQueries || [userQuery];
                                // Merge with file analysis queries if any
                                if (contentAnalysis && contentAnalysis.searchQueries) {
                                    searchQueriesToUse = [...new Set([...searchQueriesToUse, ...contentAnalysis.searchQueries])];
                                }
                            }
                        }

                        // 3. Execution Loop
                        if (needsSearch) {
                            let loopCount = 0;
                            const MAX_LOOPS = 3;
                            let isSufficient = false;
                            let queriesToRun = [...searchQueriesToUse];
                            const seenQueries = new Set();

                            while (loopCount < MAX_LOOPS && !isSufficient) {
                                loopCount++;
                                this.searchStatus = `Searching web (Round ${loopCount})...`;

                                // Run searches in parallel
                                const searchPromises = queriesToRun
                                    .filter(q => !seenQueries.has(q))
                                    .map(q => {
                                        seenQueries.add(q);
                                        return this.searchTavily(q).catch(e => {
                                            console.warn(`Search failed for "${q}":`, e);
                                            return null;
                                        });
                                    });

                                if (searchPromises.length === 0) break; // No new queries

                                const results = await Promise.all(searchPromises);

                                // Collect results
                                let newTextSources = [];
                                let newImages = [];
                                results.forEach(r => {
                                    if (r && r.results) {
                                        newTextSources.push(...r.results.map(item => ({
                                            title: item.title || 'Untitled',
                                            url: item.url || '',
                                            content: item.content || ''
                                        })));
                                    }
                                    if (r && r.images && Array.isArray(r.images)) {
                                        newImages.push(...r.images);
                                    }
                                });

                                allImages.push(...newImages);

                                if (newTextSources.length > 0) {
                                    sources = this.deduplicateSources([...sources, ...newTextSources]);
                                    this.messages[assistantMsgIndex].sources = sources; // Update UI
                                    this.$nextTick(() => this.refreshIcons());

                                    // Evaluate
                                    const evaluation = await this.evaluateSearchContext(userQuery, sources);
                                    console.log(`Evaluation Round ${loopCount}:`, evaluation);

                                    if (evaluation.isSufficient) {
                                        isSufficient = true;
                                    } else if (evaluation.newQueries && evaluation.newQueries.length > 0) {
                                        queriesToRun = evaluation.newQueries;
                                    } else {
                                        break; // No new queries suggested
                                    }
                                } else {
                                    break; // No results found
                                }
                            }
                            this.searchStatus = 'Synthesizing answer...';

                            // Add search images info to prompt (text only - CORS prevents fetching)
                            if (allImages.length > 0) {
                                const uniqueImages = allImages.filter((img, idx, arr) =>
                                    idx === arr.findIndex(i => i.url === img.url)
                                ).slice(0, 5);

                                const imageDesc = uniqueImages.map((img, i) =>
                                    `[Image ${i + 1}] ${img.alt_description || img.description || 'Relevant image'}`
                                ).join('\n');
                                prompt += `\n\nAvailable Search Images (for reference):\n${imageDesc}`;
                            }
                        }

                        // 4. Construct Final Prompt
                        const contextStr = sources.map((s, i) => `[${i + 1}] Title: ${s.title}\nURL: ${s.url}\nContent: ${s.content.slice(0, 2000)}`).join('\n\n');

                        let analysisContextStr = '';
                        if (contentAnalysis) {
                            analysisContextStr = `\nFile Analysis:\n- Description/Summary: ${contentAnalysis.description}\n- Main topic: ${contentAnalysis.mainTopic}`;
                        }

                        const systemContext = await this.buildSystemGroundingContext(true);

                        if (needsSearch && sources.length > 0) {
                            // Case 1: Search was needed and results were found
                            prompt = `${systemContext}

You are Ka0S_Perplexed, an AI search engine. Answer the user's query based on the provided context.

User Query: "${userQuery}"

Conversation History:
${conversationHistory || 'None'}
${analysisContextStr}

Web Context:
${contextStr}

Instructions:
- Answer the query comprehensively using the provided context.
- Consider the current date when answering time-sensitive questions.
- If the context is insufficient, state what is missing.
- ALWAYS cite sources using [1], [2] notation.
- Use Markdown.
- Be helpful and direct.
`;
                        } else if (needsSearch && sources.length === 0) {
                            // Case 2: Search was needed but NO results found
                            prompt = `${systemContext}

You are Ka0S_Perplexed, an AI search engine.
                            
User Query: "${userQuery}"

Conversation History:
${conversationHistory || 'None'}
${analysisContextStr}

Instructions:
- I attempted to search the web for this query but found NO relevant results.
- Please inform the user that no information was found.
- You may answer based on your general knowledge if appropriate, but clearly state that this is not from the search results.
- Be helpful but honest about the lack of search data.
`;
                        } else {
                            // Case 3: No search needed (General Chat / Creative / Greeting)
                            prompt = `${systemContext}

You are Ka0S_Perplexed, a helpful and intelligent AI assistant.

User Query: "${userQuery}"

Conversation History:
${conversationHistory || 'None'}
${analysisContextStr}

Instructions:
- Answer the user's query naturally and helpfully.
- This is a general conversation or creative request, so you do not need to cite sources unless you are referring to the attached files.
- Use Markdown.
- Be engaging and polite.
`;
                        }

                        // 5. Process attached files for Gemini (Multimodal)
                        let parts = [];
                        if (this.selectedFiles.length > 0) {
                            for (let file of this.selectedFiles) {
                                if (file.data) {
                                    parts.push({
                                        inline_data: {
                                            mime_type: file.type,
                                            data: file.data
                                        }
                                    });
                                } else if (file.content) {
                                    prompt += `\n\n--- Content of ${file.name} ---\n${file.content.slice(0, 15000)}`;
                                }
                            }
                        }

                        parts.unshift({ text: prompt });

                        // 6. Stream Response
                        await this.streamGemini(parts, (chunk) => {
                            this.messages[assistantMsgIndex].content += chunk;
                            const container = document.getElementById('chat-container');
                            container.scrollTop = container.scrollHeight;
                            // Throttled icon refresh could go here, but maybe not needed for plain text
                        });

                        // 7. Select Relevant Images (after response is complete)
                        if (allImages.length > 0 && needsSearch) {
                            this.searchStatus = 'Selecting relevant images...';
                            const selectedImages = await this.selectRelevantImages(
                                userQuery,
                                this.messages[assistantMsgIndex].content,
                                allImages
                            );
                            if (selectedImages && selectedImages.length > 0) {
                                this.messages[assistantMsgIndex].selectedImages = selectedImages;
                                this.$nextTick(() => this.refreshIcons());
                            }
                        }

                    } catch (error) {
                        console.error('Error in sendMessage:', error);
                        this.messages[assistantMsgIndex].content += `\n\n**Error:** ${error.message}`;
                    } finally {
                        this.messages[assistantMsgIndex].loading = false;
                        this.isLoading = false;
                        this.searchStatus = '';
                        this.selectedFiles = [];
                        this.filePreviews = [];
                        this.saveHistory();
                    }
                },

                // Helper: Extract valid JSON from text response
                extractJSON(text) {
                    if (!text) return null;

                    // Remove markdown code blocks
                    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                    // Find the first { and count braces to find matching }
                    let startIdx = text.indexOf('{');
                    if (startIdx === -1) return null;

                    let braceCount = 0;
                    for (let i = startIdx; i < text.length; i++) {
                        if (text[i] === '{') braceCount++;
                        else if (text[i] === '}') {
                            braceCount--;
                            if (braceCount === 0) {
                                return text.substring(startIdx, i + 1);
                            }
                        }
                    }

                    return null;
                },

                // File Analysis & Context Generation
                async analyzeAttachmentsAndGenerateQueries(files, userQuery) {
                    // Analyze images and text files to generate optimized search queries
                    if (!files || files.length === 0) return null;

                    try {
                        this.searchStatus = 'Analyzing attached files...';
                        console.log('Starting analysis for', files.length, 'files');

                        const systemContext = await this.buildSystemGroundingContext();

                        // Build parts array
                        const parts = [];

                        // Add files (images, PDFs, videos)
                        for (let file of files) {
                            if (file.data && file.type && (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('video/'))) {
                                parts.push({
                                    inline_data: {
                                        mime_type: file.type,
                                        data: file.data
                                    }
                                });
                            } else if (file.content) {
                                // Add text content
                                parts.push({
                                    text: `Content of file "${file.name}":\n${file.content.slice(0, 20000)}`
                                });
                            }
                        }

                        // Add analysis prompt
                        parts.push({
                            text: `${systemContext}\n\nAnalyze the attached file(s) (images and/or text) to generate web search queries.
User query: "${userQuery}"

Consider the current date when generating search queries for time-sensitive topics.

Respond with ONLY valid JSON (no markdown):
{
  "description": "2-3 sentence description of what you see or read in the files",
  "mainTopic": "the primary subject in one phrase",
  "searchQueries": ["specific search query 1", "specific search query 2", "specific search query 3"]
}`
                        });

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts }],
                                generationConfig: {
                                    temperature: 0.3,
                                    maxOutputTokens: 32768,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) {
                            console.warn('File analysis API failed:', response.status);
                            return null;
                        }

                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text;

                        if (!text) {
                            console.warn('No text in file analysis response', data);
                            return null;
                        }

                        console.log('File analysis raw response:', text);

                        // Extract valid JSON from response
                        const jsonStr = this.extractJSON(text);
                        if (!jsonStr) {
                            console.warn('Could not extract JSON from file analysis response:', text);
                            return null;
                        }

                        console.log('Extracted JSON:', jsonStr);
                        const result = JSON.parse(jsonStr);
                        console.log('File analysis result:', result);
                        this.searchStatus = '';
                        return result;
                    } catch (e) {
                        console.error('File analysis failed:', e);
                        this.searchStatus = '';
                        return null;
                    }
                },

                // Search Refinement & Deep Search
                async checkSearchQuality(query, results) {
                    // Ask Gemini if search results are sufficient
                    try {
                        const systemContext = await this.buildSystemGroundingContext();
                        const prompt = `${systemContext}\n\nQuery: "${query}"

Search Results (${results.length} found):
${results.map((r, i) => `${i + 1}. ${r.title}`).join('\n')}

Are these results specific and detailed enough to comprehensively answer the query? Consider the current date when evaluating result quality. Be strict - require evidence that results cover the topic. Respond ONLY with JSON (no markdown, no code blocks):
{"isSufficient": false, "reason": "reason why"}`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.2,
                                    maxOutputTokens: 32768,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) return { isSufficient: false };
                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

                        if (!text) {
                            console.warn('Quality check response empty. Full data:', JSON.stringify(data, null, 2));
                        } else {
                            console.log('Quality check raw response:', text);
                        }

                        // Extract valid JSON from response
                        const jsonStr = this.extractJSON(text);
                        if (!jsonStr) {
                            console.warn('Could not extract JSON from quality check response:', text);
                            return { isSufficient: false };
                        }

                        console.log('Extracted quality check JSON:', jsonStr);
                        const result = JSON.parse(jsonStr);
                        console.debug('Quality check result:', result);
                        return result;
                    } catch (e) {
                        console.error('Quality check failed, assuming insufficient:', e);
                        return { isSufficient: false };
                    }
                },

                async generateSearchQueries(originalQuery, existingResults, count = 1) {
                    // Generate refined search queries based on current results
                    try {
                        const systemContext = await this.buildSystemGroundingContext();
                        const resultsSummary = existingResults.map((r, i) => `${i + 1}. ${r.title}`).join('\n');
                        const prompt = `${systemContext}\n\nOriginal query: "${originalQuery}"\n\nCurrent search results:\n${resultsSummary}\n\nGenerate ${count} improved search ${count === 1 ? 'query' : 'queries'} to find better information. Consider the current date when formulating queries. Return ONLY a JSON array of strings: ["query1"${count > 1 ? ', "query2"' : ''}]`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.7,
                                    maxOutputTokens: 32768,
                                    responseMimeType: 'application/json'
                                },
                                safetySettings: [
                                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                                ]
                            })
                        });

                        if (!response.ok) return [];
                        const data = await response.json();
                        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '[]';

                        console.log('Query generation raw response:', text);

                        // Try to extract JSON array
                        const jsonStr = this.extractJSON(text) || text.trim();
                        console.log('Extracted query JSON:', jsonStr);

                        const result = JSON.parse(jsonStr);
                        return Array.isArray(result) ? result : [];
                    } catch (e) {
                        console.error('Query generation failed:', e);
                        return [];
                    }
                },

                // New: Gemini-First Search Planning
                async determineSearchNeeds(userQuery, conversationHistory) {
                    try {
                        this.searchStatus = 'Planning search strategy...';
                        const systemContext = await this.buildSystemGroundingContext();

                        const prompt = `${systemContext}

You are an expert research assistant. Your goal is to determine if a user's query requires a web search to be answered correctly and comprehensively.

User Query: "${userQuery}"

Conversation History:
${conversationHistory || 'None'}

Instructions:
1. Analyze the query considering the CURRENT DATE above. Is it asking for factual information, current events, specific data, or something that requires external knowledge beyond your April 2024 cutoff? If yes, it NEEDS search.
2. Is it a simple greeting, a request for creative writing (poem, code, joke), or a question about the conversation itself? If yes, it likely DOES NOT need search.
3. If it needs search, formulate 1-3 specific, effective search queries.
4. If the query is complex, break it down into component searches.

Respond ONLY with valid JSON:
{
  "needsSearch": boolean,
  "rationale": "Brief explanation of why search is or isn't needed",
  "searchQueries": ["query 1", "query 2"]
}`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.3,
                                    maxOutputTokens: 16384,
                                    responseMimeType: 'application/json'
                                }
                            })
                        });

                        if (!response.ok) throw new Error('Planning request failed');
                        const data = await response.json();
                        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                        const jsonStr = this.extractJSON(text);
                        return jsonStr ? JSON.parse(jsonStr) : { needsSearch: true, searchQueries: [userQuery] };

                    } catch (e) {
                        console.error('Search planning failed:', e);
                        // Fallback to default behavior
                        return { needsSearch: true, searchQueries: [userQuery] };
                    }
                },

                // New: Context Evaluation
                async evaluateSearchContext(userQuery, currentSources) {
                    try {
                        this.searchStatus = 'Evaluating search results...';
                        const systemContext = await this.buildSystemGroundingContext();
                        const contextStr = currentSources.map((s, i) => `[${i + 1}] Title: ${s.title}\nSnippet: ${s.content.slice(0, 500)}`).join('\n\n');

                        const prompt = `${systemContext}

You are a research manager. Evaluate if the gathered search results are sufficient to answer the user's query comprehensively.

User Query: "${userQuery}"

Current Search Results:
${contextStr}

Instructions:
1. Read the search results considering the CURRENT DATE above. Do they contain the specific facts, figures, or details requested?
2. Are there conflicting pieces of information that need resolution?
3. Is the information outdated relative to the current date?
4. If the results are sufficient, set "isSufficient" to true.
5. If NOT sufficient, provide a "missingInformation" summary and generate 1-2 "newQueries" to find that missing info.

Respond ONLY with valid JSON:
{
  "isSufficient": boolean,
  "missingInformation": "What is missing (if anything)",
  "newQueries": ["refined query 1"]
}`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.3,
                                    maxOutputTokens: 16384,
                                    responseMimeType: 'application/json'
                                }
                            })
                        });

                        if (!response.ok) return { isSufficient: true };
                        const data = await response.json();
                        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                        const jsonStr = this.extractJSON(text);
                        return jsonStr ? JSON.parse(jsonStr) : { isSufficient: true };

                    } catch (e) {
                        console.error('Context evaluation failed:', e);
                        return { isSufficient: true };
                    }
                },

                deduplicateSources(sourcesArray) {
                    // Remove duplicate sources by URL, keeping the first occurrence
                    const seen = new Set();
                    return sourcesArray.filter(source => {
                        if (seen.has(source.url)) return false;
                        seen.add(source.url);
                        return true;
                    });
                },

                async selectRelevantImages(userQuery, responseContent, availableImages) {
                    // Ask Gemini to select the most relevant images to display
                    if (!availableImages || availableImages.length === 0) return [];

                    try {
                        // Deduplicate images by URL
                        const uniqueImages = availableImages.filter((img, idx, arr) =>
                            idx === arr.findIndex(i => i.url === img.url)
                        ).slice(0, 10); // Limit to 10 candidates

                        if (uniqueImages.length === 0) return [];

                        const imageList = uniqueImages.map((img, i) =>
                            `[${i}] URL: ${img.url}\n    Description: ${img.description || 'No description'}`
                        ).join('\n');

                        const systemContext = await this.buildSystemGroundingContext();

                        const prompt = `${systemContext}

You are an image curator. Select the most relevant images to accompany this response.

User Query: "${userQuery}"

Response Summary (first 500 chars):
${responseContent.slice(0, 500)}...

Available Images:
${imageList}

Instructions:
1. Select 1-3 images that best illustrate or complement the response.
2. Prioritize images that are directly relevant to the query topic.
3. Avoid duplicate or very similar images.
4. If none are relevant, return an empty array.

Respond ONLY with valid JSON:
{
  "selectedIndices": [0, 2],
  "reason": "Brief explanation of why these images were selected"
}`;

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${this.apiKeys.gemini}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0.2,
                                    maxOutputTokens: 16384,
                                    responseMimeType: 'application/json'
                                }
                            })
                        });

                        if (!response.ok) {
                            console.warn('Image selection request failed:', response.status);
                            return [];
                        }

                        const data = await response.json();
                        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                        console.log('Image selection raw response:', text);
                        console.log('Full response data:', JSON.stringify(data, null, 2));
                        const jsonStr = this.extractJSON(text);

                        if (!jsonStr) {
                            console.warn('Could not extract JSON from image selection response');
                            console.warn('Raw text was:', text);
                            // Fallback: return first 3 images if selection fails
                            console.log('Falling back to first 3 images');
                            return uniqueImages.slice(0, 3);
                        }

                        const result = JSON.parse(jsonStr);
                        console.log('Image selection result:', result);

                        // Map selected indices back to image objects
                        const selectedImages = (result.selectedIndices || [])
                            .filter(idx => idx >= 0 && idx < uniqueImages.length)
                            .map(idx => uniqueImages[idx]);

                        return selectedImages;
                    } catch (e) {
                        console.error('Image selection failed:', e);
                        // Fallback: return first 3 images if selection fails
                        const uniqueImages = availableImages.filter((img, idx, arr) =>
                            idx === arr.findIndex(i => i.url === img.url)
                        ).slice(0, 3);
                        return uniqueImages;
                    }
                },

                async performDeepSearch() {
                    // Perform deep search with 4 total queries
                    const lastAssistantIdx = this.messages.findIndex((m, i) => i === this.messages.length - 1 && m.role === 'assistant');
                    if (lastAssistantIdx === -1) return;

                    const msg = this.messages[lastAssistantIdx];
                    const userQuery = this.messages[lastAssistantIdx - 1]?.content || '';

                    if (!userQuery) return;

                    this.isLoading = true;
                    msg.loading = true;
                    msg.deepSearchPerformed = true;

                    try {
                        let allSources = msg.sources || [];
                        let allImages = [];

                        // Generate 3 additional search queries
                        this.searchStatus = 'Generating search strategies...';
                        const newQueries = await this.generateSearchQueries(userQuery, allSources, 3);

                        // Perform 3 more searches
                        for (let i = 0; i < newQueries.length; i++) {
                            this.searchStatus = `Searching(${i + 2}/4)...`;
                            try {
                                const results = await this.searchTavily(newQueries[i]);
                                if (results && results.results) {
                                    const newSources = results.results.map(r => ({
                                        title: r.title || 'Untitled',
                                        url: r.url || '',
                                        content: r.content || ''
                                    }));
                                    allSources = allSources.concat(newSources);
                                }
                                // Collect images from search
                                if (results && results.images && Array.isArray(results.images)) {
                                    allImages.push(...results.images);
                                }
                            } catch (e) {
                                console.warn(`Search ${i + 2} failed: `, e);
                            }
                        }

                        // Deduplicate and update sources
                        msg.sources = this.deduplicateSources(allSources);

                        // Re-generate answer with all sources
                        this.searchStatus = 'Generating comprehensive answer...';
                        msg.content = '';

                        const contextStr = msg.sources.map((s, i) => `[${i + 1}]Title: ${s.title} \nURL: ${s.url} \nContent: ${s.content.slice(0, 2000)} `).join('\n\n');
                        const systemContext = await this.buildSystemGroundingContext(true);

                        const prompt = `${systemContext}

You are Ka0S_Perplexed, an AI search engine. Answer queries based on the provided context (this is an expanded search with more comprehensive results).

Current Query: ${userQuery}

Expanded Context (from 4 searches):
${contextStr}

Instructions:
- Provide an even more comprehensive answer using all available context.
- Synthesize information from multiple sources.
- Cite your sources using [1], [2] notation inline.
- Use Markdown for formatting.
- Do NOT list sources - they are shown separately.
- Provide a detailed, in-depth response.`;

                        const parts = [{ text: prompt }];
                        await this.streamGemini(parts, (chunk) => {
                            msg.content += chunk;
                        });

                        // Select relevant images for deep search
                        if (allImages.length > 0) {
                            this.searchStatus = 'Selecting relevant images...';
                            const selectedImages = await this.selectRelevantImages(userQuery, msg.content, allImages);
                            if (selectedImages && selectedImages.length > 0) {
                                msg.selectedImages = selectedImages;
                            }
                        }

                        this.searchStatus = '';
                        this.saveHistory();
                    } catch (error) {
                        console.error('Deep search error:', error);
                        msg.content += `\n\n ** Error during deep search:** ${error.message} `;
                        this.searchStatus = '';
                    } finally {
                        this.isLoading = false;
                        msg.loading = false;
                    }
                },

                // API Integrations
                async searchTavily(query) {
                    let adjustedQuery = query;
                    let domains = [];
                    let searchDepth = "basic";

                    // Focus Mode Logic
                    if (this.focusMode === 'Reddit') {
                        adjustedQuery += ' site:reddit.com';
                        domains = ['reddit.com'];
                    } else if (this.focusMode === 'Academic') {
                        adjustedQuery += ' academic paper';
                    } else if (this.focusMode === 'Wolfram Alpha') {
                        adjustedQuery += ' wolfram alpha';
                    }

                    const response = await fetch('https://api.tavily.com/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: this.apiKeys.tavily,
                            query: adjustedQuery,
                            search_depth: searchDepth,
                            include_answer: false,
                            max_results: 7,
                            include_images: true,
                            include_image_descriptions: true,
                            include_domains: domains.length > 0 ? domains : undefined
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Tavily Search failed');
                    }
                    return await response.json();
                },

                async streamGemini(parts, onChunk) {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:streamGenerateContent?key=${this.apiKeys.gemini}`;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                topP: 0.95,
                                topK: 64,
                                maxOutputTokens: 32768,
                                responseMimeType: 'text/plain'
                            },
                            safetySettings: [
                                {
                                    category: 'HARM_CATEGORY_HARASSMENT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_HATE_SPEECH',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                },
                                {
                                    category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                                }
                            ]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Gemini API failed: ${response.status} ${response.statusText} - ${errorText}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;

                        // Regex patterns to match text from Gemini stream responses
                        // Matches: "text": "actual text content"
                        // Handles escaped characters within the text
                        const textRegex = /"text"\s*:\s*"((?:[^"\\]|\\.)*)"/g;
                        let match;

                        while ((match = textRegex.exec(chunk)) !== null) {
                            try {
                                // Unescape the captured text
                                const escapedText = match[1];
                                const text = JSON.parse(`"${escapedText}"`);
                                if (text && text.trim()) {
                                    onChunk(text);
                                }
                            } catch (e) {
                                console.warn('Text extraction error:', e.message);
                            }
                        }
                    }
                },

                // Markdown Rendering
                renderMarkdown(text) {
                    // Parse markdown first
                    const rawHtml = marked.parse(text);

                    // Post-process citations [1] -> <a ...>[1]</a>
                    // This must happen after markdown parsing to avoid markdown escaping the HTML
                    const sanitized = DOMPurify.sanitize(rawHtml);
                    const withCitations = sanitized.replace(/\[(\d+)\]/g, '<a href="#source-$1" class="citation-link" title="Source $1">$1</a>');

                    return withCitations;
                }
            }
        }
    </script>
</body>

</html>